<!DOCTYPE html>
<html lang="en" data-root="https://fsprojects.github.io/FSharp.Data/">
<head>
    <meta charset="UTF-8">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <meta content="FSharp.Data" name="author">
    <!-- Opengraph properties (https://ogp.me/) -->
    <meta property="og:site_name" content="FSharp.Data">
    <meta property="og:title" content="Type Inference and Missing Values
" />
    <meta property="og:url" content="https://fsprojects.github.io/FSharp.Data/library/TypeInference.html">
    <meta property="og:type" content="website" />
    <!-- Twitter cards (https://developer.twitter.com/en/docs/twitter-for-websites/cards/overview/summary-card-with-large-image) -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="https://fsprojects.github.io/FSharp.Data/">
    <meta name="twitter:title" content="Type Inference and Missing Values
">
    
    <title>Type Inference and Missing Values
 | FSharp.Data</title>
    <link href="https://fonts.googleapis.com" rel="preconnect">
    <link crossorigin href="https://fonts.gstatic.com" rel="preconnect">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet">
    <script src="https://code.iconify.design/iconify-icon/1.0.7/iconify-icon.min.js"></script>
    <link href="https://fsprojects.github.io/FSharp.Data/img/favicon.ico" rel="icon" sizes="32x32" type="image/png"/>
    <script type="application/javascript" src="https://fsprojects.github.io/FSharp.Data/content/fsdocs-theme-set-dark.js"></script>
    <link href="https://fsprojects.github.io/FSharp.Data/content/fsdocs-default.css" rel="stylesheet" type="text/css"/>
    <link href="https://fsprojects.github.io/FSharp.Data/content/fsdocs-theme.css" rel="stylesheet" type="text/css"/>
    
    
</head>
<body class="content">
<header>
    <div class="start">
        <div id="menu-toggle">
            <iconify-icon class="icon closed" height="22" icon="eva:menu-fill" width="22"></iconify-icon>
            <iconify-icon class="icon open" height="22" icon="mi:close" width="22"></iconify-icon>
            <input type="checkbox" name="mobile-menu" />
            <ul class="menu">
                <li class="nav-header">Links</li>
                <li class="nav-item"><a class="nav-link" href="https://github.com/fsprojects/FSharp.Data/blob/master/LICENSE.md">License</a>
                </li>
                <li class="nav-item"><a class="nav-link"
                                        href="https://github.com/fsprojects/FSharp.Data/blob/master/RELEASE_NOTES.md">Release
                    Notes</a></li>
                <li class="nav-item"><a class="nav-link" href="https://github.com/fsprojects/FSharp.Data/">Source
                    Repository</a></li>
                <li class="nav-header active">
  Type Providers
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/CsvProvider.html">
    CSV Type Provider

  </a>
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/HtmlProvider.html">
    HTML Type Provider

  </a>
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/JsonProvider.html">
    JSON Type Provider

  </a>
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/XmlProvider.html">
    XML Type Provider

  </a>
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/WorldBank.html">
    WorldBank Provider

  </a>
</li>             
<li class="nav-item active">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/TypeInference.html">
    Type Inference and Missing Values

  </a>
</li>             
<li class="nav-header ">
  Utilities
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/Http.html">
    HTTP Utilities

  </a>
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/CsvFile.html">
    CSV Parser

  </a>
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/HtmlParser.html">
    HTML Parser

  </a>
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/HtmlCssSelectors.html">
    HTML CSS selectors

  </a>
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/JsonValue.html">
    JSON Parser

  </a>
</li>             
<li class="nav-header ">
  Tutorials
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/tutorials/JsonAnonymizer.html">
    Anonymizing JSON

  </a>
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/tutorials/JsonToXml.html">
    Converting between JSON and XML

  </a>
</li>             
<li class="nav-header ">
  Other
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/JsonSchema.html">
    Using JSON Schema with the JSON Type Provider

  </a>
</li>
                <li class="nav-header">
  API Reference
</li>             
<li class="nav-item">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/reference/index.html">
    All Namespaces
  </a>
</li>
            </ul>
        </div>
        <a href="https://fsprojects.github.io/FSharp.Data/">
            <img alt="Header menu logo" src="https://fsprojects.github.io/FSharp.Data/img/logo.png">
            <strong>FSharp.Data</strong>
        </a>
    </div>
    <div class="end">
        <a href="https://github.com/fsprojects/FSharp.Data/" target="_blank">
            <iconify-icon icon="uil:github" width="26" height="26"></iconify-icon>
        </a>
        <iconify-icon id="search-btn" icon="carbon:search" class="search" width="24" height="24"></iconify-icon>
        <fsdocs-theme-toggle></fsdocs-theme-toggle>
    </div>
</header>
<aside id="fsdocs-main-menu">
    <ul class="menu">
        <li class="nav-header">Links</li>
        <li class="nav-item"><a class="nav-link" href="https://github.com/fsprojects/FSharp.Data/blob/master/LICENSE.md">License</a>
        </li>
        <li class="nav-item"><a class="nav-link"
                                href="https://github.com/fsprojects/FSharp.Data/blob/master/RELEASE_NOTES.md">Release
            Notes</a></li>
        <li class="nav-item"><a class="nav-link" href="https://github.com/fsprojects/FSharp.Data/">Source
            Repository</a></li>
        <li class="nav-header active">
  Type Providers
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/CsvProvider.html">
    CSV Type Provider

  </a>
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/HtmlProvider.html">
    HTML Type Provider

  </a>
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/JsonProvider.html">
    JSON Type Provider

  </a>
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/XmlProvider.html">
    XML Type Provider

  </a>
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/WorldBank.html">
    WorldBank Provider

  </a>
</li>             
<li class="nav-item active">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/TypeInference.html">
    Type Inference and Missing Values

  </a>
</li>             
<li class="nav-header ">
  Utilities
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/Http.html">
    HTTP Utilities

  </a>
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/CsvFile.html">
    CSV Parser

  </a>
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/HtmlParser.html">
    HTML Parser

  </a>
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/HtmlCssSelectors.html">
    HTML CSS selectors

  </a>
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/JsonValue.html">
    JSON Parser

  </a>
</li>             
<li class="nav-header ">
  Tutorials
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/tutorials/JsonAnonymizer.html">
    Anonymizing JSON

  </a>
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/tutorials/JsonToXml.html">
    Converting between JSON and XML

  </a>
</li>             
<li class="nav-header ">
  Other
</li>             
<li class="nav-item ">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/library/JsonSchema.html">
    Using JSON Schema with the JSON Type Provider

  </a>
</li>
        <li class="nav-header">
  API Reference
</li>             
<li class="nav-item">
  <a class="nav-link" href="https://fsprojects.github.io/FSharp.Data/reference/index.html">
    All Namespaces
  </a>
</li>
    </ul>
</aside>
<main>
    <div id="content">
        
<h1><a name="Type-Inference-and-Missing-Values" class="anchor" href="#Type-Inference-and-Missing-Values">Type Inference and Missing Values</a></h1>
<p>This page describes the <strong>type inference rules</strong> used by the FSharp.Data type providers
(<a href="CsvProvider.html">CSV</a>, <a href="JsonProvider.html">JSON</a>, <a href="XmlProvider.html">XML</a> and <a href="HtmlProvider.html">HTML</a>).
Understanding these rules helps you know what F# types to expect for each property,
and how to handle missing, null, or optional values at runtime.</p>
<h2><a name="Overview" class="anchor" href="#Overview">Overview</a></h2>
<p>All FSharp.Data type providers infer types from a <strong>sample document</strong> (or a list of samples)
at compile time (design time). The generated F# types reflect the structure of the sample.
At runtime, any document with a compatible structure can be read — but the generated types
are fixed by the sample.</p>
<p>A key principle: <strong>the sample should be representative.</strong> If a property is present in the
sample but absent from runtime data, it can raise a <code>KeyNotFoundException</code>. Conversely,
if runtime data contains new properties not in the sample, they are not accessible via the
generated type (though they may still be reachable through the underlying <code>JsonValue</code>,
<code>XElement</code>, etc.).</p>
<h2><a name="Numeric-Type-Inference" class="anchor" href="#Numeric-Type-Inference">Numeric Type Inference</a></h2>
<p>When inferring numeric types, the providers prefer the most precise type that can represent
all values. The preference order (most preferred first) is:</p>
<ol>
<li><code>int</code> – 32-bit signed integer</li>
<li><code>int64</code> – 64-bit signed integer</li>
<li><code>decimal</code> – exact decimal arithmetic (preferred for financial/monetary values)</li>
<li>
<code>float</code> – 64-bit floating point (used when <code>decimal</code> cannot represent the value,
or when missing values appear in a CSV column that would otherwise be <code>decimal</code>)
</li>
</ol>
<p>If values in a column or array mix two types, the provider automatically promotes to the
wider type. For example, a JSON array <code>[1, 2, 3.14]</code> will produce <code>decimal</code> values.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">open</span> <span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="id">FSharp</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs2', 2)" onmouseover="showTip(event, 'fs2', 2)" class="id">Data</span>

<span class="c">// int is inferred when all values are integers</span>
<span class="k">type</span> <span onmouseout="hideTip(event, 'fs3', 3)" onmouseover="showTip(event, 'fs3', 3)" class="rt">IntsOnly</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs4', 4)" onmouseover="showTip(event, 'fs4', 4)" class="rt">JsonProvider</span><span class="pn">&lt;</span><span class="s">&quot;&quot;&quot; [1, 2, 3] &quot;&quot;&quot;</span><span class="pn">&gt;</span>

<span class="c">// decimal is inferred when any value has a fractional part</span>
<span class="k">type</span> <span onmouseout="hideTip(event, 'fs5', 5)" onmouseover="showTip(event, 'fs5', 5)" class="rt">WithDecimal</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs4', 6)" onmouseover="showTip(event, 'fs4', 6)" class="rt">JsonProvider</span><span class="pn">&lt;</span><span class="s">&quot;&quot;&quot; [1, 2, 3.14] &quot;&quot;&quot;</span><span class="pn">&gt;</span>
</code></pre>
<table class="pre"><tr><td><pre><code>type IntsOnly = FSharp.Data.JsonProvider&lt;...&gt;
type WithDecimal = FSharp.Data.JsonProvider&lt;...&gt;</code></pre></td></tr></table>
<h2><a name="Boolean-Inference-CSV" class="anchor" href="#Boolean-Inference-CSV">Boolean Inference (CSV)</a></h2>
<p>In CSV files, columns whose values are exclusively drawn from the set
<code>0</code>, <code>1</code>, <code>Yes</code>, <code>No</code>, <code>True</code>, <code>False</code> (case-insensitive) are inferred as <code>bool</code>.
Any other values in the column cause it to be treated as a string.</p>
<h2><a name="Date-and-Time-Inference" class="anchor" href="#Date-and-Time-Inference">Date and Time Inference</a></h2>
<p>The providers recognise date and time strings in standard ISO 8601 formats:</p>
<table>
<thead>
<tr class="header">
<th><p>Inferred Type</p></th>
<th><p>When Used</p></th>
<th><p>Example Value</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><code>DateTime</code></p></td>
<td><p>Date + time strings (default)</p></td>
<td><p><code>"2023-06-15T12:00:00"</code></p></td>
</tr>
<tr class="even">
<td><p><code>DateTimeOffset</code></p></td>
<td><p>Date + time + timezone offset (always)</p></td>
<td><p><code>"2023-06-15T12:00:00+02:00"</code></p></td>
</tr>
<tr class="odd">
<td><p><code>DateTimeOffset</code></p></td>
<td><p>Any date + time string when <code>PreferDateTimeOffset=true</code></p></td>
<td><p><code>"2023-06-15T12:00:00"</code></p></td>
</tr>
<tr class="even">
<td><p><code>DateOnly</code> (.NET 6+)</p></td>
<td><p>Date-only strings when <code>PreferDateOnly=true</code></p></td>
<td><p><code>"2023-06-15"</code></p></td>
</tr>
<tr class="odd">
<td><p><code>TimeOnly</code> (.NET 6+)</p></td>
<td><p>Time-only strings when <code>PreferDateOnly=true</code></p></td>
<td><p><code>"12:00:00"</code></p></td>
</tr>
</tbody>
</table>

<p>By default (<code>PreferDateOnly = false</code>), date-only strings such as <code>"2023-06-15"</code> are
inferred as <code>DateTime</code> for backward compatibility. Set <code>PreferDateOnly = true</code> on
.NET 6 and later to infer them as <code>DateOnly</code> instead.</p>
<p>Set <code>PreferDateTimeOffset = true</code> to infer all date-time values (that would otherwise be
<code>DateTime</code>) as <code>DateTimeOffset</code> instead. Values that already carry an explicit timezone
offset (e.g. <code>"2023-06-15T12:00:00+02:00"</code>) are always inferred as <code>DateTimeOffset</code>
regardless of this flag. <code>PreferDateTimeOffset</code> and <code>PreferDateOnly</code> are independent:
<code>DateOnly</code> values stay as <code>DateOnly</code> even when <code>PreferDateTimeOffset=true</code>.</p>
<p>If a column mixes <code>DateOnly</code> and <code>DateTime</code> values, they are unified to <code>DateTime</code>.</p>
<h2><a name="Missing-Values-and-Optionals" class="anchor" href="#Missing-Values-and-Optionals">Missing Values and Optionals</a></h2>
<p>This is the most important topic for understanding how the providers behave at runtime.
The rules differ slightly across providers.</p>
<h3><a name="JSON-Provider" class="anchor" href="#JSON-Provider">JSON Provider</a></h3>
<p>In JSON, a property can be <strong>absent</strong> from an object, or its value can be <strong>null</strong> (<code>null</code> literal).
Both cases are handled the same way by the JSON type provider:</p>
<ul>
<li>If a property is <strong>missing in some samples</strong>, it is inferred as <code>option&lt;T&gt;</code>.</li>
<li>If a property has a <strong>null value</strong> in some samples, it is inferred as <code>option&lt;T&gt;</code>.</li>
</ul>
<p>This means <code>None</code> represents either a missing key or a <code>null</code> value at runtime.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// &#39;age&#39; is missing from the second record → inferred as option&lt;int&gt;</span>
<span class="k">type</span> <span onmouseout="hideTip(event, 'fs6', 7)" onmouseover="showTip(event, 'fs6', 7)" class="rt">People</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs4', 8)" onmouseover="showTip(event, 'fs4', 8)" class="rt">JsonProvider</span><span class="pn">&lt;</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">  [ { &quot;name&quot;:&quot;Alice&quot;, &quot;age&quot;:30 },</span>
<span class="s">    { &quot;name&quot;:&quot;Bob&quot; } ] &quot;&quot;&quot;</span><span class="pn">&gt;</span>

<span class="k">for</span> <span onmouseout="hideTip(event, 'fs7', 9)" onmouseover="showTip(event, 'fs7', 9)" class="fn">person</span> <span class="k">in</span> <span onmouseout="hideTip(event, 'fs6', 10)" onmouseover="showTip(event, 'fs6', 10)" class="rt">People</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs8', 11)" onmouseover="showTip(event, 'fs8', 11)" class="id">GetSamples</span><span class="pn">(</span><span class="pn">)</span> <span class="k">do</span>
    <span onmouseout="hideTip(event, 'fs9', 12)" onmouseover="showTip(event, 'fs9', 12)" class="fn">printf</span> <span class="s">&quot;</span><span class="pf">%s</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs7', 13)" onmouseover="showTip(event, 'fs7', 13)" class="fn">person</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs10', 14)" onmouseover="showTip(event, 'fs10', 14)" class="id">Name</span>

    <span class="k">match</span> <span onmouseout="hideTip(event, 'fs7', 15)" onmouseover="showTip(event, 'fs7', 15)" class="fn">person</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs11', 16)" onmouseover="showTip(event, 'fs11', 16)" class="id">Age</span> <span class="k">with</span>
    <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs12', 17)" onmouseover="showTip(event, 'fs12', 17)" class="uc">Some</span> <span onmouseout="hideTip(event, 'fs13', 18)" onmouseover="showTip(event, 'fs13', 18)" class="fn">age</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs14', 19)" onmouseover="showTip(event, 'fs14', 19)" class="fn">printfn</span> <span class="s">&quot; (age </span><span class="pf">%d</span><span class="s">)&quot;</span> <span onmouseout="hideTip(event, 'fs13', 20)" onmouseover="showTip(event, 'fs13', 20)" class="fn">age</span>
    <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs15', 21)" onmouseover="showTip(event, 'fs15', 21)" class="uc">None</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs14', 22)" onmouseover="showTip(event, 'fs14', 22)" class="fn">printfn</span> <span class="s">&quot; (age unknown)&quot;</span>
</code></pre>
<table class="pre"><tr><td><pre><code>Alice (age 30)
Bob (age unknown)
type People = JsonProvider&lt;...&gt;
val it: unit = ()</code></pre></td></tr></table>
<blockquote>
<p><strong>Important runtime note:</strong> If a property is present and non-null in <em>all</em> samples, it will be
inferred as a non-optional type. If such a property is then absent or null in runtime data,
accessing it will throw a runtime exception. Use multiple samples (or <code>SampleIsList=true</code>)
to ensure optional properties are correctly modelled.</p>
</blockquote>
<h4><a name="Null-values-in-JSON" class="anchor" href="#Null-values-in-JSON">Null values in JSON</a></h4>
<p>A JSON <code>null</code> value that appears as the value of a typed property is treated as <code>None</code>.
A <code>null</code> value in a heterogeneous context (e.g. an array of numbers and nulls) is
represented via the <code>option</code> mechanism on the generated accessor.</p>
<h3><a name="CSV-Provider" class="anchor" href="#CSV-Provider">CSV Provider</a></h3>
<p>CSV files do not have a native null/missing concept. Instead, certain string values are
treated as missing. By default, the following strings (case-insensitive) are recognised
as missing: <code>NaN</code>, <code>NA</code>, <code>N/A</code>, <code>#N/A</code>, <code>:</code>, <code>-</code>, <code>TBA</code>, <code>TBD</code> (and empty string <code>""</code>).</p>
<p>You can override this list with the <code>MissingValues</code> static parameter.</p>
<p>When a column has at least one missing value, the inferred type changes as follows:</p>
<table>
<thead>
<tr class="header">
<th><p>Base type</p></th>
<th><p>With missing values (default)</p></th>
<th><p>With <code>PreferOptionals=true</code></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><code>int</code></p></td>
<td><p><code>Nullable&lt;int&gt;</code> (<code>int?</code>)</p></td>
<td><p><code>int option</code></p></td>
</tr>
<tr class="even">
<td><p><code>int64</code></p></td>
<td><p><code>Nullable&lt;int64&gt;</code> (<code>int64?</code>)</p></td>
<td><p><code>int64 option</code></p></td>
</tr>
<tr class="odd">
<td><p><code>decimal</code></p></td>
<td><p><code>float</code> (using <code>Double.NaN</code>)</p></td>
<td><p><code>float option</code></p></td>
</tr>
<tr class="even">
<td><p><code>float</code></p></td>
<td><p><code>float</code> (using <code>Double.NaN</code>)</p></td>
<td><p><code>float option</code></p></td>
</tr>
<tr class="odd">
<td><p><code>bool</code></p></td>
<td><p><code>bool option</code></p></td>
<td><p><code>bool option</code></p></td>
</tr>
<tr class="even">
<td><p><code>DateTime</code></p></td>
<td><p><code>DateTime option</code></p></td>
<td><p><code>DateTime option</code></p></td>
</tr>
<tr class="odd">
<td><p><code>DateTimeOffset</code></p></td>
<td><p><code>DateTimeOffset option</code></p></td>
<td><p><code>DateTimeOffset option</code></p></td>
</tr>
<tr class="even">
<td><p><code>DateOnly</code></p></td>
<td><p><code>Nullable&lt;DateOnly&gt;</code></p></td>
<td><p><code>DateOnly option</code></p></td>
</tr>
<tr class="odd">
<td><p><code>Guid</code></p></td>
<td><p><code>Guid option</code></p></td>
<td><p><code>Guid option</code></p></td>
</tr>
<tr class="even">
<td><p><code>string</code></p></td>
<td><p><code>string</code> (empty string <code>""</code> for missing)</p></td>
<td><p><code>string option</code></p></td>
</tr>
</tbody>
</table>

<p>The key differences between the default and <code>PreferOptionals=true</code>:
- In the default mode, integers use <code>Nullable&lt;T&gt;</code> and decimals are widened to <code>float</code> with <code>Double.NaN</code>.
- With <code>PreferOptionals=true</code>, <strong>all</strong> types use <code>T option</code> and you never get <code>Double.NaN</code> or <code>Nullable&lt;T&gt;</code>.
- Strings are never made into <code>string option</code> by default (empty string represents missing); use
<code>PreferOptionals=true</code> to get <code>string option</code>.</p>
<p><strong>Design-time safety:</strong> If your sample file contains no missing values in a column, but you know
that production data may have missing values, set <code>AssumeMissingValues=true</code> to force the provider
to treat all columns as nullable/optional.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// With AssumeMissingValues=true, all columns become nullable/optional</span>
<span class="c">// even if the sample has no missing values</span>
<span class="k">type</span> <span onmouseout="hideTip(event, 'fs16', 23)" onmouseover="showTip(event, 'fs16', 23)" class="d">SafeCsv</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs17', 24)" onmouseover="showTip(event, 'fs17', 24)" class="rt">CsvProvider</span><span class="pn">&lt;</span><span class="s">&quot;A,B\n1,2\n3,4&quot;</span><span class="pn">,</span> <span class="fn">AssumeMissingValues</span><span class="o">=</span><span class="k">true</span><span class="pn">&gt;</span>

<span class="c">// With PreferOptionals=true, all columns use &#39;option&#39; instead of Nullable or NaN</span>
<span class="k">type</span> <span onmouseout="hideTip(event, 'fs18', 25)" onmouseover="showTip(event, 'fs18', 25)" class="d">OptionalsCsv</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs17', 26)" onmouseover="showTip(event, 'fs17', 26)" class="rt">CsvProvider</span><span class="pn">&lt;</span><span class="s">&quot;A,B\n1,2\n3,4&quot;</span><span class="pn">,</span> <span class="fn">PreferOptionals</span><span class="o">=</span><span class="k">true</span><span class="pn">&gt;</span>
</code></pre>
<table class="pre"><tr><td><pre><code>type SafeCsv = CsvProvider&lt;...&gt;
type OptionalsCsv = CsvProvider&lt;...&gt;</code></pre></td></tr></table>
<h3><a name="XML-Provider" class="anchor" href="#XML-Provider">XML Provider</a></h3>
<p>In XML, values can be missing at the attribute or element level:</p>
<ul>
<li>
If an <strong>attribute</strong> is present in some sample elements but absent in others, it is
inferred as <code>option&lt;T&gt;</code>.
</li>
<li>If a <strong>child element</strong> is present in some samples but not all, it is inferred as optional.</li>
<li>
If an attribute or element is <strong>never present</strong> in the sample, it cannot be accessed via the
generated type at all (use <code>XElement.Attribute(...)</code> dynamically in that case).
</li>
</ul>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// &#39;born&#39; attribute missing from one author → option&lt;int&gt;</span>
<span class="k">type</span> <span onmouseout="hideTip(event, 'fs19', 27)" onmouseover="showTip(event, 'fs19', 27)" class="rt">Authors</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs20', 28)" onmouseover="showTip(event, 'fs20', 28)" class="rt">XmlProvider</span><span class="pn">&lt;</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">  &lt;authors&gt;</span>
<span class="s">    &lt;author name=&quot;Karl Popper&quot; born=&quot;1902&quot; /&gt;</span>
<span class="s">    &lt;author name=&quot;Thomas Kuhn&quot; /&gt;</span>
<span class="s">  &lt;/authors&gt;</span>
<span class="s">  &quot;&quot;&quot;</span><span class="pn">&gt;</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs21', 29)" onmouseover="showTip(event, 'fs21', 29)" class="id">sample</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 30)" onmouseover="showTip(event, 'fs19', 30)" class="rt">Authors</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs19', 31)" onmouseover="showTip(event, 'fs19', 31)" class="id">GetSample</span><span class="pn">(</span><span class="pn">)</span>

<span class="k">for</span> <span onmouseout="hideTip(event, 'fs22', 32)" onmouseover="showTip(event, 'fs22', 32)" class="fn">author</span> <span class="k">in</span> <span onmouseout="hideTip(event, 'fs21', 33)" onmouseover="showTip(event, 'fs21', 33)" class="id">sample</span><span class="pn">.</span><span class="id">Authors</span> <span class="k">do</span>
    <span onmouseout="hideTip(event, 'fs9', 34)" onmouseover="showTip(event, 'fs9', 34)" class="fn">printf</span> <span class="s">&quot;</span><span class="pf">%s</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs22', 35)" onmouseover="showTip(event, 'fs22', 35)" class="fn">author</span><span class="pn">.</span><span class="id">Name</span>

    <span class="k">match</span> <span onmouseout="hideTip(event, 'fs22', 36)" onmouseover="showTip(event, 'fs22', 36)" class="fn">author</span><span class="pn">.</span><span class="id">Born</span> <span class="k">with</span>
    <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs12', 37)" onmouseover="showTip(event, 'fs12', 37)" class="uc">Some</span> <span onmouseout="hideTip(event, 'fs23', 38)" onmouseover="showTip(event, 'fs23', 38)" class="fn">year</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs14', 39)" onmouseover="showTip(event, 'fs14', 39)" class="fn">printfn</span> <span class="s">&quot; (born </span><span class="pf">%d</span><span class="s">)&quot;</span> <span onmouseout="hideTip(event, 'fs23', 40)" onmouseover="showTip(event, 'fs23', 40)" class="fn">year</span>
    <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs15', 41)" onmouseover="showTip(event, 'fs15', 41)" class="uc">None</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs14', 42)" onmouseover="showTip(event, 'fs14', 42)" class="fn">printfn</span> <span class="s">&quot;&quot;</span>
</code></pre>
<table class="pre"><tr><td><pre><code></code></pre></td></tr></table>
<blockquote>
<p><strong>Note:</strong> If an attribute or element is absent from <em>all</em> sample data but present at
runtime, it cannot be accessed through the generated type. You must include at least
one occurrence (possibly with a dummy value) in the sample to have the provider
generate an optional property.</p>
</blockquote>
<h2><a name="Heterogeneous-Types" class="anchor" href="#Heterogeneous-Types">Heterogeneous Types</a></h2>
<p>Sometimes a property can hold values of different types. The JSON type provider handles
this by generating a type with multiple optional accessors — one per observed type.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// Value can be int or string → generates .Number and .String accessors</span>
<span class="k">type</span> <span onmouseout="hideTip(event, 'fs24', 43)" onmouseover="showTip(event, 'fs24', 43)" class="rt">HetValues</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs4', 44)" onmouseover="showTip(event, 'fs4', 44)" class="rt">JsonProvider</span><span class="pn">&lt;</span><span class="s">&quot;&quot;&quot; [{&quot;value&quot;:94}, {&quot;value&quot;:&quot;hello&quot;}] &quot;&quot;&quot;</span><span class="pn">&gt;</span>

<span class="k">for</span> <span onmouseout="hideTip(event, 'fs25', 45)" onmouseover="showTip(event, 'fs25', 45)" class="fn">item</span> <span class="k">in</span> <span onmouseout="hideTip(event, 'fs24', 46)" onmouseover="showTip(event, 'fs24', 46)" class="rt">HetValues</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs8', 47)" onmouseover="showTip(event, 'fs8', 47)" class="id">GetSamples</span><span class="pn">(</span><span class="pn">)</span> <span class="k">do</span>
    <span class="k">match</span> <span onmouseout="hideTip(event, 'fs25', 48)" onmouseover="showTip(event, 'fs25', 48)" class="fn">item</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs26', 49)" onmouseover="showTip(event, 'fs26', 49)" class="prop">Value</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs27', 50)" onmouseover="showTip(event, 'fs27', 50)" class="id">Number</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs25', 51)" onmouseover="showTip(event, 'fs25', 51)" class="fn">item</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs26', 52)" onmouseover="showTip(event, 'fs26', 52)" class="prop">Value</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs28', 53)" onmouseover="showTip(event, 'fs28', 53)" class="id">String</span> <span class="k">with</span>
    <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs12', 54)" onmouseover="showTip(event, 'fs12', 54)" class="uc">Some</span> <span onmouseout="hideTip(event, 'fs29', 55)" onmouseover="showTip(event, 'fs29', 55)" class="fn">n</span><span class="pn">,</span> <span class="id">_</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs14', 56)" onmouseover="showTip(event, 'fs14', 56)" class="fn">printfn</span> <span class="s">&quot;Number: </span><span class="pf">%d</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs29', 57)" onmouseover="showTip(event, 'fs29', 57)" class="fn">n</span>
    <span class="pn">|</span> <span class="id">_</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs12', 58)" onmouseover="showTip(event, 'fs12', 58)" class="uc">Some</span> <span onmouseout="hideTip(event, 'fs30', 59)" onmouseover="showTip(event, 'fs30', 59)" class="fn">s</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs14', 60)" onmouseover="showTip(event, 'fs14', 60)" class="fn">printfn</span> <span class="s">&quot;String: </span><span class="pf">%s</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs30', 61)" onmouseover="showTip(event, 'fs30', 61)" class="fn">s</span>
    <span class="pn">|</span> <span class="id">_</span> <span class="k">-&gt;</span> <span class="pn">(</span><span class="pn">)</span>
</code></pre>
<table class="pre"><tr><td><pre><code>Number: 94
String: hello
type HetValues = JsonProvider&lt;...&gt;
val it: unit = ()</code></pre></td></tr></table>
<h2><a name="Design-Time-vs-Runtime-Behaviour" class="anchor" href="#Design-Time-vs-Runtime-Behaviour">Design-Time vs Runtime Behaviour</a></h2>
<p>The type providers perform inference <strong>at compile time</strong> using the sample document.
At runtime, the actual data is parsed against the inferred schema. This has a few
important implications:</p>
<ol>
<li>
<p><strong>Properties that are required at design-time may be missing at runtime.</strong> If a
property is always present and non-null in your sample, the provider generates a
non-optional accessor. If runtime data omits that property, a <code>KeyNotFoundException</code>
is thrown when you access it.</p>
</li>
<li>
<p><strong>New properties in runtime data are ignored.</strong> If runtime JSON has extra keys that
are not in the sample, those keys are simply not accessible via the generated type.</p>
</li>
<li>
<p><strong>The sample should cover the full range of variability.</strong> Include examples of all
optional properties and heterogeneous value types in your sample. Use <code>SampleIsList=true</code>
for JSON/XML when the root is an array of samples.</p>
</li>
<li>
<p><strong>Runtime errors are lazy.</strong> The providers do not validate the entire document on load.
A missing or mistyped field only causes an error when that specific property is accessed.</p>
</li>
</ol>
<h2><a name="Summary-of-Inference-Control-Parameters" class="anchor" href="#Summary-of-Inference-Control-Parameters">Summary of Inference-Control Parameters</a></h2>
<p>The following static parameters let you override the default inference behaviour:</p>
<table>
<thead>
<tr class="header">
<th><p>Parameter</p></th>
<th><p>Providers</p></th>
<th><p>Effect</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><code>PreferOptionals</code></p></td>
<td><p>CSV, JSON, XML</p></td>
<td><p>Use <code>T option</code> for all missing/null values instead of <code>Nullable&lt;T&gt;</code> or <code>Double.NaN</code></p></td>
</tr>
<tr class="even">
<td><p><code>AssumeMissingValues</code></p></td>
<td><p>CSV</p></td>
<td><p>Treat every column as nullable/optional even if the sample has no missing values</p></td>
</tr>
<tr class="odd">
<td><p><code>MissingValues</code></p></td>
<td><p>CSV</p></td>
<td><p>Comma-separated list of strings to recognise as missing (replaces defaults)</p></td>
</tr>
<tr class="even">
<td><p><code>InferRows</code></p></td>
<td><p>CSV</p></td>
<td><p>Number of rows to use for type inference (default 1000; 0 = all rows)</p></td>
</tr>
<tr class="odd">
<td><p><code>SampleIsList</code></p></td>
<td><p>JSON, XML</p></td>
<td><p>Treat the top-level array as a list of sample objects, not a single sample</p></td>
</tr>
<tr class="even">
<td><p><code>PreferDateOnly</code></p></td>
<td><p>CSV, JSON, XML</p></td>
<td><p>Infer date-only strings as <code>DateOnly</code> on .NET 6+ (default <code>false</code>)</p></td>
</tr>
<tr class="odd">
<td><p><code>PreferDateTimeOffset</code></p></td>
<td><p>CSV, JSON, XML</p></td>
<td><p>Infer all date-time values as <code>DateTimeOffset</code> instead of <code>DateTime</code> (default <code>false</code>)</p></td>
</tr>
<tr class="even">
<td><p><code>InferenceMode</code></p></td>
<td><p>JSON, XML</p></td>
<td><p>Enable inline schema annotations (<code>ValuesAndInlineSchemasHints</code> or <code>ValuesAndInlineSchemasOverrides</code>)</p></td>
</tr>
<tr class="odd">
<td><p><code>Schema</code></p></td>
<td><p>CSV</p></td>
<td><p>Override column names and/or types directly</p></td>
</tr>
</tbody>
</table>

<p>For full details on each parameter, see the individual provider documentation:
<a href="CsvProvider.html">CSV</a> · <a href="JsonProvider.html">JSON</a> · <a href="XmlProvider.html">XML</a> · <a href="HtmlProvider.html">HTML</a></p>

        <div class="fsdocs-tip" id="fs1">Multiple items<br />namespace FSharp<br /><br />--------------------<br />namespace Microsoft.FSharp</div>
<div class="fsdocs-tip" id="fs2">Multiple items<br />namespace FSharp.Data<br /><br />--------------------<br />namespace Microsoft.FSharp.Data</div>
<div class="fsdocs-tip" id="fs3">type IntsOnly = JsonProvider&lt;...&gt;</div>
<div class="fsdocs-tip" id="fs4">type JsonProvider<br /><em>&lt;summary&gt;Typed representation of a JSON document.&lt;/summary&gt;
           &lt;param name=&#39;Sample&#39;&gt;Location of a JSON sample file or a string containing a sample JSON document.&lt;/param&gt;
           &lt;param name=&#39;SampleIsList&#39;&gt;If true, sample should be a list of individual samples for the inference.&lt;/param&gt;
           &lt;param name=&#39;RootName&#39;&gt;The name to be used to the root type. Defaults to `Root`.&lt;/param&gt;
           &lt;param name=&#39;Culture&#39;&gt;The culture used for parsing numbers and dates. Defaults to the invariant culture.&lt;/param&gt;
           &lt;param name=&#39;Encoding&#39;&gt;The encoding used to read the sample. You can specify either the character set name or the codepage number. Defaults to UTF8 for files, and to ISO-8859-1 the for HTTP requests, unless `charset` is specified in the `Content-Type` response header.&lt;/param&gt;
           &lt;param name=&#39;ResolutionFolder&#39;&gt;A directory that is used when resolving relative file references (at design time and in hosted execution).&lt;/param&gt;
           &lt;param name=&#39;EmbeddedResource&#39;&gt;When specified, the type provider first attempts to load the sample from the specified resource
              (e.g. &#39;MyCompany.MyAssembly, resource_name.json&#39;). This is useful when exposing types generated by the type provider.&lt;/param&gt;
           &lt;param name=&#39;InferTypesFromValues&#39;&gt;
              This parameter is deprecated. Please use InferenceMode instead.
              If true, turns on additional type inference from values.
              (e.g. type inference infers string values such as &quot;123&quot; as ints and values constrained to 0 and 1 as booleans.)&lt;/param&gt;
           &lt;param name=&#39;PreferDictionaries&#39;&gt;If true, json records are interpreted as dictionaries when the names of all the fields are inferred (by type inference rules) into the same non-string primitive type.&lt;/param&gt;
           &lt;param name=&#39;InferenceMode&#39;&gt;Possible values:
              | NoInference -&gt; Inference is disabled. All values are inferred as the most basic type permitted for the value (i.e. string or number or bool).
              | ValuesOnly -&gt; Types of values are inferred from the Sample. Inline schema support is disabled. This is the default.
              | ValuesAndInlineSchemasHints -&gt; Types of values are inferred from both values and inline schemas. Inline schemas are special string values that can define a type and/or unit of measure. Supported syntax: typeof&amp;lt;type&amp;gt; or typeof{type} or typeof&amp;lt;type&amp;lt;measure&amp;gt;&amp;gt; or typeof{type{measure}}. Valid measures are the default SI units, and valid types are &lt;c&gt;int&lt;/c&gt;, &lt;c&gt;int64&lt;/c&gt;, &lt;c&gt;bool&lt;/c&gt;, &lt;c&gt;float&lt;/c&gt;, &lt;c&gt;decimal&lt;/c&gt;, &lt;c&gt;date&lt;/c&gt;, &lt;c&gt;datetimeoffset&lt;/c&gt;, &lt;c&gt;timespan&lt;/c&gt;, &lt;c&gt;guid&lt;/c&gt; and &lt;c&gt;string&lt;/c&gt;.
              | ValuesAndInlineSchemasOverrides -&gt; Same as ValuesAndInlineSchemasHints, but value inferred types are ignored when an inline schema is present.
           &lt;/param&gt;
           &lt;param name=&#39;Schema&#39;&gt;Location of a JSON Schema file or a string containing a JSON Schema document. When specified, Sample and SampleIsList must not be used.&lt;/param&gt;
           &lt;param name=&#39;PreferDateOnly&#39;&gt;When true on .NET 6+, date-only strings (e.g. &quot;2023-01-15&quot;) are inferred as DateOnly and time-only strings as TimeOnly. Defaults to false for backward compatibility.&lt;/param&gt;
           &lt;param name=&#39;UseOriginalNames&#39;&gt;When true, JSON property names are used as-is for generated property names instead of being normalized to PascalCase. Defaults to false.&lt;/param&gt;
           &lt;param name=&#39;OmitNullFields&#39;&gt;When true, optional fields with value None are omitted from the generated JSON rather than serialized as null. Defaults to false.&lt;/param&gt;
           &lt;param name=&#39;PreferOptionals&#39;&gt;When set to true (default), inference will use the option type for missing or null values. When false, inference will prefer to use empty string or double.NaN for missing values where possible, matching the default CsvProvider behavior.&lt;/param&gt;
           &lt;param name=&#39;PreferDateTimeOffset&#39;&gt;When true, date-time strings without an explicit timezone offset are inferred as DateTimeOffset (using the local offset) instead of DateTime. Defaults to false.&lt;/param&gt;
           &lt;param name=&#39;ExceptionIfMissing&#39;&gt;When true, accessing a non-optional field that is missing in the JSON data raises an exception instead of returning a default value (empty string for string, NaN for float). Defaults to false for backward compatibility.&lt;/param&gt;</em></div>
<div class="fsdocs-tip" id="fs5">type WithDecimal = JsonProvider&lt;...&gt;</div>
<div class="fsdocs-tip" id="fs6">type People = JsonProvider&lt;...&gt;</div>
<div class="fsdocs-tip" id="fs7">val person: JsonProvider&lt;...&gt;.Root</div>
<div class="fsdocs-tip" id="fs8">JsonProvider&lt;...&gt;.GetSamples() : JsonProvider&lt;...&gt;.Root array</div>
<div class="fsdocs-tip" id="fs9">val printf: format: Printf.TextWriterFormat&lt;&#39;T&gt; -&gt; &#39;T</div>
<div class="fsdocs-tip" id="fs10">property JsonProvider&lt;...&gt;.Root.Name: string with get</div>
<div class="fsdocs-tip" id="fs11">property JsonProvider&lt;...&gt;.Root.Age: Option&lt;int&gt; with get</div>
<div class="fsdocs-tip" id="fs12">union case Option.Some: Value: &#39;T -&gt; Option&lt;&#39;T&gt;</div>
<div class="fsdocs-tip" id="fs13">val age: int</div>
<div class="fsdocs-tip" id="fs14">val printfn: format: Printf.TextWriterFormat&lt;&#39;T&gt; -&gt; &#39;T</div>
<div class="fsdocs-tip" id="fs15">union case Option.None: Option&lt;&#39;T&gt;</div>
<div class="fsdocs-tip" id="fs16">type SafeCsv = CsvProvider&lt;...&gt;</div>
<div class="fsdocs-tip" id="fs17">type CsvProvider<br /><em>&lt;summary&gt;Typed representation of a CSV file.&lt;/summary&gt;
           &lt;param name=&#39;Sample&#39;&gt;Location of a CSV sample file or a string containing a sample CSV document.&lt;/param&gt;
           &lt;param name=&#39;Separators&#39;&gt;Column delimiter(s). Defaults to &lt;c&gt;,&lt;/c&gt;.&lt;/param&gt;
           &lt;param name=&#39;InferRows&#39;&gt;Number of rows to use for inference. Defaults to &lt;c&gt;1000&lt;/c&gt;. If this is zero, all rows are used.&lt;/param&gt;
           &lt;param name=&#39;Schema&#39;&gt;Optional column types, in a comma separated list. Valid types are &lt;c&gt;int&lt;/c&gt;, &lt;c&gt;int64&lt;/c&gt;, &lt;c&gt;bool&lt;/c&gt;, &lt;c&gt;float&lt;/c&gt;, &lt;c&gt;decimal&lt;/c&gt;, &lt;c&gt;date&lt;/c&gt;, &lt;c&gt;datetimeoffset&lt;/c&gt;, &lt;c&gt;timespan&lt;/c&gt;, &lt;c&gt;guid&lt;/c&gt;, &lt;c&gt;string&lt;/c&gt;, &lt;c&gt;int?&lt;/c&gt;, &lt;c&gt;int64?&lt;/c&gt;, &lt;c&gt;bool?&lt;/c&gt;, &lt;c&gt;float?&lt;/c&gt;, &lt;c&gt;decimal?&lt;/c&gt;, &lt;c&gt;date?&lt;/c&gt;, &lt;c&gt;datetimeoffset?&lt;/c&gt;, &lt;c&gt;timespan?&lt;/c&gt;, &lt;c&gt;guid?&lt;/c&gt;, &lt;c&gt;int option&lt;/c&gt;, &lt;c&gt;int64 option&lt;/c&gt;, &lt;c&gt;bool option&lt;/c&gt;, &lt;c&gt;float option&lt;/c&gt;, &lt;c&gt;decimal option&lt;/c&gt;, &lt;c&gt;date option&lt;/c&gt;, &lt;c&gt;datetimeoffset option&lt;/c&gt;, &lt;c&gt;timespan option&lt;/c&gt;, &lt;c&gt;guid option&lt;/c&gt; and &lt;c&gt;string option&lt;/c&gt;.
           You can also specify a unit and the name of the column like this: &lt;c&gt;Name (type&amp;lt;unit&amp;gt;)&lt;/c&gt;, or you can override only the name. If you don&#39;t want to specify all the columns, you can reference the columns by name like this: &lt;c&gt;ColumnName=type&lt;/c&gt;.&lt;/param&gt;
           &lt;param name=&#39;HasHeaders&#39;&gt;Whether the sample contains the names of the columns as its first line.&lt;/param&gt;
           &lt;param name=&#39;IgnoreErrors&#39;&gt;Whether to ignore rows that have the wrong number of columns or which can&#39;t be parsed using the inferred or specified schema. Otherwise an exception is thrown when these rows are encountered.&lt;/param&gt;
           &lt;param name=&#39;SkipRows&#39;&gt;Skips the first n rows of the CSV file.&lt;/param&gt;
           &lt;param name=&#39;AssumeMissingValues&#39;&gt;When set to true, the type provider will assume all columns can have missing values, even if in the provided sample all values are present. Defaults to false.&lt;/param&gt;
           &lt;param name=&#39;PreferOptionals&#39;&gt;When set to true, inference will prefer to use the option type instead of nullable types, &lt;c&gt;double.NaN&lt;/c&gt; or &lt;c&gt;&quot;&quot;&lt;/c&gt; for missing values. Defaults to false.&lt;/param&gt;
           &lt;param name=&#39;Quote&#39;&gt;The quotation mark (for surrounding values containing the delimiter). Defaults to &lt;c&gt;&quot;&lt;/c&gt;.&lt;/param&gt;
           &lt;param name=&#39;MissingValues&#39;&gt;The set of strings recognized as missing values specified as a comma-separated string (e.g., &quot;NA,N/A&quot;). Defaults to &lt;c&gt;NaN,NA,N/A,#N/A,:,-,TBA,TBD&lt;/c&gt;.&lt;/param&gt;
           &lt;param name=&#39;CacheRows&#39;&gt;Whether the rows should be caches so they can be iterated multiple times. Defaults to true. Disable for large datasets.&lt;/param&gt;
           &lt;param name=&#39;Culture&#39;&gt;The culture used for parsing numbers and dates. Defaults to the invariant culture.&lt;/param&gt;
           &lt;param name=&#39;Encoding&#39;&gt;The encoding used to read the sample. You can specify either the character set name or the codepage number. Defaults to UTF8 for files, and to ISO-8859-1 the for HTTP requests, unless &lt;c&gt;charset&lt;/c&gt; is specified in the &lt;c&gt;Content-Type&lt;/c&gt; response header.&lt;/param&gt;
           &lt;param name=&#39;ResolutionFolder&#39;&gt;A directory that is used when resolving relative file references (at design time and in hosted execution).&lt;/param&gt;
           &lt;param name=&#39;EmbeddedResource&#39;&gt;When specified, the type provider first attempts to load the sample from the specified resource 
              (e.g. &#39;MyCompany.MyAssembly, resource_name.csv&#39;). This is useful when exposing types generated by the type provider.&lt;/param&gt;
           &lt;param name=&#39;PreferDateOnly&#39;&gt;When true on .NET 6+, date-only strings are inferred as DateOnly and time-only strings as TimeOnly. Defaults to false for backward compatibility.&lt;/param&gt;
           &lt;param name=&#39;StrictBooleans&#39;&gt;When true, only &lt;c&gt;true&lt;/c&gt; and &lt;c&gt;false&lt;/c&gt; (case-insensitive) are inferred as boolean. Values such as &lt;c&gt;0&lt;/c&gt;, &lt;c&gt;1&lt;/c&gt;, &lt;c&gt;yes&lt;/c&gt;, and &lt;c&gt;no&lt;/c&gt; are treated as integers or strings respectively. Defaults to false.&lt;/param&gt;
           &lt;param name=&#39;UseOriginalNames&#39;&gt;When true, CSV column header names are used as-is for generated property names instead of being normalized (e.g. capitalizing the first letter). Defaults to false.&lt;/param&gt;
           &lt;param name=&#39;PreferDateTimeOffset&#39;&gt;When true, date-time strings without an explicit timezone offset are inferred as DateTimeOffset (using the local offset) instead of DateTime. Defaults to false.&lt;/param&gt;</em></div>
<div class="fsdocs-tip" id="fs18">type OptionalsCsv = CsvProvider&lt;...&gt;</div>
<div class="fsdocs-tip" id="fs19"></div>
<div class="fsdocs-tip" id="fs20">type XmlProvider<br /><em>&lt;summary&gt;Typed representation of a XML file.&lt;/summary&gt;
           &lt;param name=&#39;Sample&#39;&gt;Location of a XML sample file or a string containing a sample XML document.&lt;/param&gt;
           &lt;param name=&#39;SampleIsList&#39;&gt;If true, the children of the root in the sample document represent individual samples for the inference.&lt;/param&gt;
           &lt;param name=&#39;Global&#39;&gt;If true, the inference unifies all XML elements with the same name.&lt;/param&gt;                     
           &lt;param name=&#39;Culture&#39;&gt;The culture used for parsing numbers and dates. Defaults to the invariant culture.&lt;/param&gt;
           &lt;param name=&#39;Encoding&#39;&gt;The encoding used to read the sample. You can specify either the character set name or the codepage number. Defaults to UTF8 for files, and to ISO-8859-1 the for HTTP requests, unless &lt;c&gt;charset&lt;/c&gt; is specified in the &lt;c&gt;Content-Type&lt;/c&gt; response header.&lt;/param&gt;
           &lt;param name=&#39;ResolutionFolder&#39;&gt;A directory that is used when resolving relative file references (at design time and in hosted execution).&lt;/param&gt;
           &lt;param name=&#39;EmbeddedResource&#39;&gt;When specified, the type provider first attempts to load the sample from the specified resource 
              (e.g. &#39;MyCompany.MyAssembly, resource_name.xml&#39;). This is useful when exposing types generated by the type provider.&lt;/param&gt;
           &lt;param name=&#39;InferTypesFromValues&#39;&gt;
              This parameter is deprecated. Please use InferenceMode instead.
              If true, turns on additional type inference from values. 
              (e.g. type inference infers string values such as &quot;123&quot; as ints and values constrained to 0 and 1 as booleans. The XmlProvider also infers string values as JSON.)&lt;/param&gt;
           &lt;param name=&#39;Schema&#39;&gt;Location of a schema file or a string containing xsd.&lt;/param&gt;
           &lt;param name=&#39;InferenceMode&#39;&gt;Possible values:
              | NoInference -&gt; Inference is disabled. All values are inferred as the most basic type permitted for the value (usually string).
              | ValuesOnly -&gt; Types of values are inferred from the Sample. Inline schema support is disabled. This is the default.
              | ValuesAndInlineSchemasHints -&gt; Types of values are inferred from both values and inline schemas. Inline schemas are special string values that can define a type and/or unit of measure. Supported syntax: typeof&amp;lt;type&amp;gt; or typeof{type} or typeof&amp;lt;type&amp;lt;measure&amp;gt;&amp;gt; or typeof{type{measure}}. Valid measures are the default SI units, and valid types are &lt;c&gt;int&lt;/c&gt;, &lt;c&gt;int64&lt;/c&gt;, &lt;c&gt;bool&lt;/c&gt;, &lt;c&gt;float&lt;/c&gt;, &lt;c&gt;decimal&lt;/c&gt;, &lt;c&gt;date&lt;/c&gt;, &lt;c&gt;datetimeoffset&lt;/c&gt;, &lt;c&gt;timespan&lt;/c&gt;, &lt;c&gt;guid&lt;/c&gt; and &lt;c&gt;string&lt;/c&gt;.
              | ValuesAndInlineSchemasOverrides -&gt; Same as ValuesAndInlineSchemasHints, but value inferred types are ignored when an inline schema is present.
              Note inline schemas are not used from Xsd documents.
           &lt;/param&gt;
           &lt;param name=&#39;PreferDateOnly&#39;&gt;When true on .NET 6+, date-only strings are inferred as DateOnly and time-only strings as TimeOnly. Defaults to false for backward compatibility.&lt;/param&gt;
           &lt;param name=&#39;DtdProcessing&#39;&gt;Controls how DTD declarations in the XML are handled. Accepted values: &quot;Ignore&quot; (default, silently skips DTD processing, safe for most cases), &quot;Prohibit&quot; (throws on any DTD declaration), &quot;Parse&quot; (enables full DTD processing including entity expansion, use with caution).&lt;/param&gt;
           &lt;param name=&#39;UseOriginalNames&#39;&gt;When true, XML element and attribute names are used as-is for generated property names instead of being normalized to PascalCase. Defaults to false.&lt;/param&gt;
           &lt;param name=&#39;PreferOptionals&#39;&gt;When set to true (default), inference will use the option type for missing or absent values. When false, inference will prefer to use empty string or double.NaN for missing values where possible, matching the default CsvProvider behavior.&lt;/param&gt;
           &lt;param name=&#39;UseSchemaTypeNames&#39;&gt;When true and a Schema is provided, the XSD complex type name is used for the generated F# type instead of the element name. This causes multiple elements that share the same XSD type to map to a single F# type. Defaults to false for backward compatibility.&lt;/param&gt;
           &lt;param name=&#39;PreferDateTimeOffset&#39;&gt;When true, date-time strings without an explicit timezone offset are inferred as DateTimeOffset (using the local offset) instead of DateTime. Defaults to false.&lt;/param&gt;
           &lt;param name=&#39;ExceptionIfMissing&#39;&gt;When true, accessing a non-optional field that is missing in the XML data raises an exception instead of returning a default value (empty string for string, NaN for float). Defaults to false for backward compatibility.&lt;/param&gt;</em></div>
<div class="fsdocs-tip" id="fs21">val sample: obj</div>
<div class="fsdocs-tip" id="fs22">val author: obj</div>
<div class="fsdocs-tip" id="fs23">val year: int</div>
<div class="fsdocs-tip" id="fs24">type HetValues = JsonProvider&lt;...&gt;</div>
<div class="fsdocs-tip" id="fs25">val item: JsonProvider&lt;...&gt;.Root</div>
<div class="fsdocs-tip" id="fs26">property JsonProvider&lt;...&gt;.Root.Value: JsonProvider&lt;...&gt;.IntOrString with get</div>
<div class="fsdocs-tip" id="fs27">property JsonProvider&lt;...&gt;.IntOrString.Number: Option&lt;int&gt; with get</div>
<div class="fsdocs-tip" id="fs28">property JsonProvider&lt;...&gt;.IntOrString.String: Option&lt;string&gt; with get</div>
<div class="fsdocs-tip" id="fs29">val n: int</div>
<div class="fsdocs-tip" id="fs30">val s: string</div>

    </div>
</main>
<aside id="fsdocs-page-menu">
    <p id="on-this-page">On this page</p>
    <ul>
  <li class="level-1">
    <a href="#Type-Inference-and-Missing-Values">
      Type Inference and Missing Values
    </a>
  </li>
  <li class="level-2">
    <a href="#Overview">
      Overview
    </a>
  </li>
  <li class="level-2">
    <a href="#Numeric-Type-Inference">
      Numeric Type Inference
    </a>
  </li>
  <li class="level-2">
    <a href="#Boolean-Inference-CSV">
      Boolean Inference (CSV)
    </a>
  </li>
  <li class="level-2">
    <a href="#Date-and-Time-Inference">
      Date and Time Inference
    </a>
  </li>
  <li class="level-2">
    <a href="#Missing-Values-and-Optionals">
      Missing Values and Optionals
    </a>
  </li>
  <li class="level-3">
    <a href="#JSON-Provider">
      JSON Provider
    </a>
  </li>
  <li class="level-4">
    <a href="#Null-values-in-JSON">
      Null values in JSON
    </a>
  </li>
  <li class="level-3">
    <a href="#CSV-Provider">
      CSV Provider
    </a>
  </li>
  <li class="level-3">
    <a href="#XML-Provider">
      XML Provider
    </a>
  </li>
  <li class="level-2">
    <a href="#Heterogeneous-Types">
      Heterogeneous Types
    </a>
  </li>
  <li class="level-2">
    <a href="#Design-Time-vs-Runtime-Behaviour">
      Design-Time vs Runtime Behaviour
    </a>
  </li>
  <li class="level-2">
    <a href="#Summary-of-Inference-Control-Parameters">
      Summary of Inference-Control Parameters
    </a>
  </li>
</ul>
</aside>
<dialog>
    <input type="search" placeholder="Search docs" />
    <div class="results">
        <ul></ul>
        <p class="empty">Type something to start searching.</p>
    </div>
</dialog>
<script type="module" src="https://fsprojects.github.io/FSharp.Data/content/fsdocs-tips.js"></script>
<script type="module" src="https://fsprojects.github.io/FSharp.Data/content/fsdocs-theme-toggle.js"></script>
<script type="module" src="https://fsprojects.github.io/FSharp.Data/content/fsdocs-theme.js"></script>
<script type="module" src="https://fsprojects.github.io/FSharp.Data/content/fsdocs-search.js"></script>

</body>
</html>