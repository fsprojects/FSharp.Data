// --------------------------------------------------------------------------------------
// MarkdownDocument runtime type for MarkdownProvider
// Front matter is exposed via IJsonDocument interface; Body is accessible directly.
// --------------------------------------------------------------------------------------
namespace FSharp.Data.Runtime.BaseTypes

open System
open System.IO
open System.Globalization
open FSharp.Data

#nowarn "10001"

/// Internal YAML-lite front matter parser.
/// Handles the subset of YAML used in markdown front matter:
/// strings, numbers, booleans, null, inline arrays, and block arrays.
module internal FrontMatterParser =

    let private parseScalar (v: string) : JsonValue =
        let v = v.Trim()

        if v = "null" || v = "~" || v = "" then
            JsonValue.Null
        elif v = "true" then
            JsonValue.Boolean true
        elif v = "false" then
            JsonValue.Boolean false
        elif v.StartsWith("\"") && v.EndsWith("\"") && v.Length >= 2 then
            JsonValue.String(v.[1 .. v.Length - 2])
        elif v.StartsWith("'") && v.EndsWith("'") && v.Length >= 2 then
            JsonValue.String(v.[1 .. v.Length - 2])
        else
            match Decimal.TryParse(v, NumberStyles.Any, CultureInfo.InvariantCulture) with
            | true, n -> JsonValue.Number n
            | _ -> JsonValue.String v

    let private parseInlineArray (s: string) : JsonValue =
        let inner = s.Trim()

        let inner =
            if inner.StartsWith("[") && inner.EndsWith("]") then
                inner.[1 .. inner.Length - 2]
            else
                inner

        if inner.Trim() = "" then
            JsonValue.Array [||]
        else
            let items = inner.Split(',') |> Array.map (fun i -> parseScalar (i.Trim()))
            JsonValue.Array items

    /// Parse YAML front matter from markdown content.
    /// Returns a list of (key, JsonValue) pairs and the body string.
    let parseFrontMatter (content: string) : (string * JsonValue) list * string =
        let normalized = content.Replace("\r\n", "\n").Replace("\r", "\n")
        let lines = normalized.Split('\n')

        if lines.Length < 2 || lines.[0].Trim() <> "---" then
            [], content
        else
            let mutable closeIdx = -1

            for i in 1 .. lines.Length - 1 do
                if closeIdx = -1 && lines.[i].Trim() = "---" then
                    closeIdx <- i

            if closeIdx = -1 then
                [], content
            else
                let fmLines = lines.[1 .. closeIdx - 1]

                let body =
                    if closeIdx + 1 < lines.Length then
                        String.Join("\n", lines.[closeIdx + 1 ..])
                    else
                        ""

                let pairs = System.Collections.Generic.List<string * JsonValue>()
                let mutable i = 0

                while i < fmLines.Length do
                    let line = fmLines.[i]
                    let colonIdx = line.IndexOf(':')

                    if colonIdx > 0 then
                        let key = line.[.. colonIdx - 1].Trim()

                        let rawValue =
                            if colonIdx + 1 < line.Length then
                                line.[colonIdx + 1 ..].Trim()
                            else
                                ""

                        if rawValue = "" then
                            // Block array: collect "  - item" lines
                            let items = System.Collections.Generic.List<JsonValue>()
                            let mutable j = i + 1

                            while j < fmLines.Length && fmLines.[j].TrimStart().StartsWith("- ") do
                                let itemStr = fmLines.[j].TrimStart().[2..]
                                items.Add(parseScalar itemStr)
                                j <- j + 1

                            if items.Count > 0 then
                                pairs.Add((key, JsonValue.Array(items.ToArray())))
                                i <- j
                            else
                                i <- i + 1
                        elif rawValue.StartsWith("[") && rawValue.EndsWith("]") then
                            pairs.Add((key, parseInlineArray rawValue))
                            i <- i + 1
                        else
                            pairs.Add((key, parseScalar rawValue))
                            i <- i + 1
                    else
                        i <- i + 1

                (pairs |> Seq.toList), body

/// <summary>Underlying representation of types generated by MarkdownProvider.</summary>
[<StructuredFormatDisplay("{JsonValue}")>]
type MarkdownDocument =

    private
        { FmJson: JsonValue
          BodyText: string
          DocPath: string }

    interface IJsonDocument with
        member x.JsonValue = x.FmJson
        member x.Path() = x.DocPath

        member x.CreateNew(value, pathIncrement) =
            { FmJson = value
              BodyText = x.BodyText
              DocPath = x.DocPath + pathIncrement }
            :> IJsonDocument

    /// The front matter represented as a JsonValue record
    member x.JsonValue = x.FmJson

    /// The markdown body content (all text after the front matter delimiter)
    member x.Body = x.BodyText

    static member private FromPairs(pairs: (string * JsonValue) list, body: string, path: string) =
        { FmJson = JsonValue.Record(pairs |> List.toArray)
          BodyText = body
          DocPath = path }

    /// Load a MarkdownDocument from a TextReader.
    static member Load(reader: TextReader) =
        let content = reader.ReadToEnd()
        let pairs, body = FrontMatterParser.parseFrontMatter content
        MarkdownDocument.FromPairs(pairs, body, "")

    /// Load a MarkdownDocument from a TextReader with an associated path for error messages.
    static member Load(reader: TextReader, path: string) =
        let content = reader.ReadToEnd()
        let pairs, body = FrontMatterParser.parseFrontMatter content
        MarkdownDocument.FromPairs(pairs, body, path)

    /// Parse sample content at design time. Returns only the front matter JsonValue.
    static member ParseSample(content: string) =
        let pairs, _ = FrontMatterParser.parseFrontMatter content
        JsonValue.Record(pairs |> List.toArray)
