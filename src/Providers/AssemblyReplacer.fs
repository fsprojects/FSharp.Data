// --------------------------------------------------------------------------------------
// Utilities for transforming F# quotations to reference types from different assemblies
// --------------------------------------------------------------------------------------

namespace ProviderImplementation

open System
open System.Collections.Generic
open System.IO
open System.Reflection
open Microsoft.FSharp.Quotations
open Microsoft.FSharp.Quotations.ExprShape
open Microsoft.FSharp.Quotations.Patterns
open Microsoft.FSharp.Reflection
open ProviderImplementation.ProvidedTypes

/// When we split a type provider into a runtime assembly and a design time assembly, we can no longer 
/// use quotations directly, because they will reference the wrong types. AssemblyReplacer fixes that 
/// by transforming the expressions generated by the quotations to have the right types. On all 
/// expressions  that we provide to InvokeCode and GetterCode of ProvidedMethod, ProvidedConstructor,
/// and ProvidedProperty, instead of (fun args -> <@@ doSomethingWith(%%args) @@>), we should use 
/// (fun args -> let args = replacer.ToDesignTime args in replacer.ToRuntime <@@ doSomethingWith(%%args) @@>)
/// When creating the Provided* type, we have to always specify the runtime type, and when it invokes
/// the function provided to InvokeCode and GetterCode, we to first transform the argument expressions
/// to the design time types, so we can splice it in the quotation, and then after that we have to convert
/// it back to the runtime type. A further complication arises because Expr.Var's have reference equality, so
/// when can't just create new Expr.Var's with the same variable name and a different type. When transforming
/// them from runtime to design time we keep them in a dictionary, so that when we convert them back to runtime
/// we can return the exact same instance that was provided to us initially.
/// Another limitation (not only of this method, but in general with type providers) is that we can never use 
/// expressions that use F# functions as parameters or return values, we always have to use felegates instead.
type AssemblyReplacer =

  /// Gets the equivalent runtime type
  abstract member ToRuntime : designTimeType:Type -> Type

  /// Gets an equivalent expression with all the types replaced with runtime equivalents
  abstract member ToRuntime : designTimeTypeExpr:Expr -> Expr

  /// Gets an equivalent expression with all the types replaced with designTime equivalents
  abstract member ToDesignTime: runtimeExpr:Expr -> Expr

[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module AssemblyReplacer =

  // We use a list for asmMappings because the Assembly type is not an IComparable and can't be stored in a map
  // In the originalsAsms list the first assembly has to be the assembly of the outer type
  let private replace asmMappings (original, originalAsms) f =
    let toAsm = 
      asmMappings
      |> Seq.tryPick (fun (fromAsm, toAsm) -> 
        if originalAsms |> List.exists (fun originalAsm -> originalAsm = fromAsm) then        
          // if we found a replacement for the outer type assembly, return it
          if fromAsm = originalAsms.Head then Some toAsm 
          // otherwise just return the original assembly of the outer type,
          // to signal that it needs to be visited, but it doesn't make sense
          // to replace it with toAsm, because that is from one of the inner types
          else Some originalAsms.Head
        else 
          None)
    match toAsm with
    | Some toAsm -> f toAsm
    | None -> original

  // A lazy version of the previous method to avoid doing unneeded work in the discriminated unions case
  let private replaceLazy asmMappings (lazyOriginal : 'a Lazy, originalAsms) f =
    let toAsm = 
      asmMappings
      |> Seq.tryPick (fun (fromAsm, toAsm) -> 
        if originalAsms |> List.exists (fun originalAsm -> originalAsm = fromAsm) then        
          // if we found a replacement for the outer type assembly, return it
          if fromAsm = originalAsms.Head then Some toAsm 
          // otherwise just return the original assembly of the outer type,
          // to signal that it needs to be visited, but it doesn't make sense
          // to replace it with toAsm, because that is from one of the inner types
          else Some originalAsms.Head
        else 
          None)
    match toAsm with
    | Some toAsm -> f toAsm
    | None -> lazyOriginal.Value

  let private getType (asm:Assembly) (t:Type) rt =
    let fixName (fullName:string) =
      if fullName.StartsWith("FSI_") then 
        // when F# Interactive is the host of the design time assembly,
        // all namespaces are prefixed with FSI_, in the runtime assembly
        // the name won't have that prefix
        fullName.Substring(fullName.IndexOf('.') + 1)
      else 
        fullName
    let getType fullName =
      if asm.FullName.StartsWith "FSI-ASSEMBLY" then
        // when F# Interactive is the host of the design time assembly,
        // for each type in the runtime assembly there might be multiple
        // versions (FSI_0001.FullTypeName, FSI_0002.FullTypeName, etc).
        // Get the last one.
        asm.GetTypes() 
        |> Seq.filter (fun t -> (fixName t.FullName) = fullName)
        |> Seq.sortBy (fun t -> t.FullName)
        |> Seq.last
      else
        asm.GetType fullName
    let newT =
      if t.IsGenericType && not t.IsGenericTypeDefinition then 
        let genericType = t.GetGenericTypeDefinition()
        let newT = getType (fixName genericType.FullName)
        if newT = null then 
          null
        else
          let typeArguments = 
            t.GetGenericArguments()
            |> Seq.map rt
            |> Seq.toArray
          newT.MakeGenericType(typeArguments)
      else 
        getType (fixName t.FullName)
    if newT = null then
      failwithf "Type '%O' not found in '%s'" t asm.Location
    newT

  // there might be multiple assemblies involved in generic types
  let private getAssemblies t =
    let rec innerGetAssemblies (t:Type) = seq {
      yield t.Assembly
      if t.IsGenericType && not t.IsGenericTypeDefinition then
        for t in t.GetGenericArguments() do
          yield! innerGetAssemblies t
    }
    t |> innerGetAssemblies |> Seq.distinct |> Seq.toList

  let rec private replaceType asmMappings (t : Type) =    
    if t.GetType().Name = "ProvidedSymbolType" then t
    elif t.GetType() = typeof<ProvidedTypeDefinition> then t
    else replace asmMappings (t, getAssemblies t) (fun toAsm -> getType toAsm t (replaceType asmMappings))

  let private replaceProperty asmMappings (p : PropertyInfo) =
    if p.GetType() = typeof<ProvidedProperty> then p
    else replace asmMappings (p, getAssemblies p.DeclaringType) (fun toAsm ->
      let t = getType toAsm p.DeclaringType (replaceType asmMappings)
      let isStatic = 
        p.CanRead && p.GetGetMethod().IsStatic || 
        p.CanWrite && p.GetSetMethod().IsStatic
      let bindingFlags = 
        BindingFlags.Public ||| BindingFlags.NonPublic ||| 
          (if isStatic then BindingFlags.Static else BindingFlags.Instance)
      let newP = t.GetProperty(p.Name, bindingFlags)
      if newP = null then
        failwithf "Property '%O' of type '%O' not found in '%s'" p t toAsm.Location
      newP)

  let private replaceField asmMappings (f : FieldInfo) =
    if f.GetType() = typeof<ProvidedField> then f
    else replace asmMappings (f, getAssemblies f.DeclaringType) (fun toAsm ->
      let t = getType toAsm f.DeclaringType (replaceType asmMappings)
      let bindingFlags = 
        (if f.IsPublic then BindingFlags.Public else BindingFlags.NonPublic) ||| 
        (if f.IsStatic then BindingFlags.Static else BindingFlags.Instance)
      let newF = t.GetField(f.Name, bindingFlags)
      if newF = null then
        failwithf "Field '%O' of type '%O' not found in '%s'" f t toAsm.Location
      newF)
  
  let private replaceMethod asmMappings (m : MethodInfo) =
    if m.GetType() = typeof<ProvidedMethod> then m
    elif m.DeclaringType.FullName = "Microsoft.FSharp.Core.LanguagePrimitives+IntrinsicFunctions" then m // these methods don't really exist, so there's no need to replace them
    else replace asmMappings (m, getAssemblies m.DeclaringType) (fun toAsm ->
        let t = getType toAsm m.DeclaringType (replaceType asmMappings)
        let parameterTypes = 
          m.GetParameters() 
          |> Seq.map (fun p -> replaceType asmMappings p.ParameterType) 
          |> Seq.toArray
        let newM =
          if m.IsGenericMethod then 
            let genericMethod = t.GetMethod(m.Name)
            if genericMethod = null then 
              null
            else
              let typeArguments = 
                m.GetGenericArguments()
                |> Seq.map (fun t -> replaceType asmMappings t) 
                |> Seq.toArray            
              genericMethod.MakeGenericMethod(typeArguments)
          else 
            t.GetMethod(m.Name, parameterTypes)
        if newM = null then
          failwithf "Method '%O' of type '%O' not found in '%s'" m t toAsm.Location
        else
          newM)

  let private replaceConstructor asmMappings (c : ConstructorInfo) =
    if c.GetType() = typeof<ProvidedConstructor> then c
    else replace asmMappings (c, getAssemblies c.DeclaringType) (fun toAsm ->
      let t = getType toAsm c.DeclaringType (replaceType asmMappings)
      let parameterTypes = 
        c.GetParameters() 
        |> Seq.map (fun p -> replaceType asmMappings p.ParameterType) 
        |> Seq.toArray
      let newC = t.GetConstructor(parameterTypes)
      if newC = null then
        failwithf "Constructor '%O' of type '%O' not found in '%s'" c t toAsm.Location
      else
        newC)

  let private replaceUnionCase asmMappings (uci : UnionCaseInfo) exprs =
    replaceLazy asmMappings (lazy (Expr.NewUnionCase (uci, exprs)), getAssemblies uci.DeclaringType) (fun toAsm ->
      let t = getType toAsm uci.DeclaringType (replaceType asmMappings)
      let constructorMethod = t.GetMethod(uci.Name)
      if constructorMethod = null then
        failwithf "Method '%s' of type '%O' not found in '%s'" uci.Name t toAsm.Location
      Expr.Call (constructorMethod, exprs))

  let private replaceVar asmMappings (varTable: IDictionary<_,_>) reversePass (v: Var) =
    if v.Type.GetType() = typeof<ProvidedTypeDefinition> then v
    else replace asmMappings (v, getAssemblies v.Type) (fun toAsm ->
      let createNewVar() = 
        Var (v.Name, getType toAsm v.Type (replaceType asmMappings), v.IsMutable)
      if reversePass then
        let newVar = createNewVar()
        // store the original var as we'll have to revert to it later
        varTable.Add(newVar, v)
        newVar
      else
        match varTable.TryGetValue v with
        | true, v -> v
        | false, _ -> 
            // It's a variable local to the quotation
            let newVar = createNewVar()
            // store it so we reuse it from now on
            varTable.Add(v, newVar)
            newVar)
  
  let rec private replaceExpr asmMappings varTable reversePass quotation =
    let rt = replaceType asmMappings
    let rp = replaceProperty asmMappings
    let rf = replaceField asmMappings
    let rm = replaceMethod asmMappings
    let rc = replaceConstructor asmMappings
    let ru = replaceUnionCase asmMappings
    let rv = replaceVar asmMappings varTable reversePass
    let re = replaceExpr asmMappings varTable reversePass
    
    match quotation with
    | Call (obj, m, args) -> 
        match obj with
        | Some obj -> Expr.Call (re obj, rm m, List.map re args)
        | None -> Expr.Call (rm m, List.map re args)
    | PropertyGet (obj, p, indexArgs) -> 
        match obj with
        | Some obj -> Expr.PropertyGet (re obj, rp p, List.map re indexArgs)
        | None -> Expr.PropertyGet (rp p, List.map re indexArgs)
    | PropertySet (obj, p, indexArgs, value) -> 
        match obj with
        | Some obj -> Expr.PropertySet (re obj, rp p, re value, List.map re indexArgs)
        | None -> Expr.PropertySet (rp p, re value, List.map re indexArgs)
    | NewObject (c, exprs) ->
        Expr.NewObject (rc c, List.map re exprs)
    | Coerce (expr, t) ->
        Expr.Coerce (re expr, rt t)
    | NewUnionCase (uci, exprs) ->
        ru uci (List.map re exprs)
    | NewRecord (t, exprs) ->
        Expr.NewRecord (rt t, List.map re exprs)
    | NewTuple (exprs) ->
        Expr.NewTuple (List.map re exprs)
    | TupleGet (expr, i) ->
        Expr.TupleGet (re expr, i)
    | NewDelegate (t, vars, expr) ->
        Expr.NewDelegate (rt t, List.map rv vars, re expr)
    | FieldGet (obj, f) -> 
        match obj with
        | Some obj -> Expr.FieldGet (re obj, rf f)
        | None -> Expr.FieldGet (rf f)
    | FieldSet (obj, f, value) -> 
        match obj with
        | Some obj -> Expr.FieldSet (re obj, rf f, re value)
        | None -> Expr.FieldSet (rf f, re value)
    | ShapeVar v -> 
        Expr.Var (rv v)
    | ShapeLambda (v, expr) -> 
        Expr.Lambda (rv v, re expr)
    | ShapeCombination (o, exprs) -> 
        RebuildShapeCombination (o, List.map re exprs)

  /// Creates an AssemblyReplacer with the provided list of designTimeAssembly*runtimeAssembly mappings
  /// Should always receive the current running assembly paired with the RuntimeAssembly from TypeProviderConfig,
  /// and in case we're targetting a different .Net framework profile, the FSharp.Core version referenced
  /// by the current assembly paired with the FSharp.Core version referenced by the runtime assembly
  let create asmMappings =
    let asmMappingsReversed = asmMappings |> List.map (fun (a, b) -> b, a)
    let variablesTable = new Dictionary<_, _>()
            
    { new AssemblyReplacer with
        member __.ToRuntime (t:Type) = t |> replaceType asmMappings
        member __.ToRuntime (e:Expr) = e |> replaceExpr asmMappings variablesTable false
        member __.ToDesignTime (e:Expr) = e |> replaceExpr asmMappingsReversed variablesTable true }
