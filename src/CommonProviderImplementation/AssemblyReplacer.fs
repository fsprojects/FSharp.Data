// --------------------------------------------------------------------------------------
// Utilities for transforming F# quotations to reference types from different assemblies
// --------------------------------------------------------------------------------------

namespace ProviderImplementation

open System
open System.Collections.Generic
open System.IO
open System.Reflection
open Microsoft.FSharp.Quotations
open Microsoft.FSharp.Quotations.ExprShape
open Microsoft.FSharp.Quotations.Patterns
open Microsoft.FSharp.Reflection
open ProviderImplementation.ProvidedTypes

/// When we split a type provider into a runtime assembly and a design time assembly, we can no longer 
/// use quotations directly, because they will reference the wrong types. AssemblyReplacer fixes that 
/// by transforming the expressions generated by the quotations to have the right types. On all 
/// expressions  that we provide to InvokeCode and GetterCode of ProvidedMethod, ProvidedConstructor,
/// and ProvidedProperty, instead of (fun args -> <@@ doSomethingWith(%%args) @@>), we should use 
/// (fun args -> let args = replacer.ToDesignTime args in replacer.ToRuntime <@@ doSomethingWith(%%args) @@>)
/// When creating the Provided* type, we have to always specify the runtime type, and when it invokes
/// the function provided to InvokeCode and GetterCode, we to first transform the argument expressions
/// to the design time types, so we can splice it in the quotation, and then after that we have to convert
/// it back to the runtime type. A further complication arises because Expr.Var's have reference equality, so
/// when can't just create new Expr.Var's with the same variable name and a different type. When transforming
/// them from runtime to design time we keep them in a dictionary, so that when we convert them back to runtime
/// we can return the exact same instance that was provided to us initially.
/// Another limitation (not only of this method, but in general with type providers) is that we can never use 
/// expressions that use F# functions as parameters or return values, we always have to use felegates instead.
type AssemblyReplacer =

  /// Gets the equivalent runtime type
  abstract member ToRuntime : designTimeType:Type -> Type

  /// Gets an equivalent expression with all the types replaced with runtime equivalents
  abstract member ToRuntime : designTimeTypeExpr:Expr -> Expr

  /// Gets an equivalent expression with all the types replaced with designTime equivalents
  abstract member ToDesignTime: runtimeExpr:Expr -> Expr

[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module AssemblyReplacer =

  // We use a list for asmMappings because the Assembly type is not an IComparable and can't be stored in a map
  // In the originalsAsms list the first assembly has to be the assembly of the outer type
  // We use a lazy type for the original to avoid doing unneeded work in the discriminated unions case
  let private replaceLazy asmMappings (lazyOriginal : 'a Lazy, originalAsms) f =
    let toAsmCandidates = 
      asmMappings
      |> List.choose (fun (fromAsm, toAsm) ->
        if originalAsms |> Array.exists (fun originalAsm -> originalAsm = fromAsm) && fromAsm = originalAsms.[0] then
          // if we found a replacement for the outer type assembly, return it
          Some toAsm
        else
          None)
    let toAsmCandidates =
      match toAsmCandidates with
      | [] ->
          asmMappings
          |> List.tryPick (fun (fromAsm, _) -> 
            if originalAsms |> Array.exists (fun originalAsm -> originalAsm = fromAsm) then
              // if we found a replacement for a inner type, just return the original
              // assembly of the outer type to signal that it needs to be visited, but it
              // doesn't make sense to replace it with toAsm
              Some [ originalAsms.[0] ]
            else
              None)
      | toAsmCandidates -> Some toAsmCandidates
    match toAsmCandidates with
    | None -> lazyOriginal.Value
    | Some toAsmCandidates -> f toAsmCandidates

  let private replace asmMappings (original, originalAsms) f =
    replaceLazy asmMappings (lazy original, originalAsms) f

  let rec private getType asmCandidates (t:Type) asmMappings ((typeCache:Dictionary<_,_>, _) as caches) =
    let getType (asm:Assembly) =
      match typeCache.TryGetValue((asm, t)) with
      | true, t -> Some t
      | false, _ ->
          let fixName (fullName:string) =
            if fullName.StartsWith("FSI_") then 
              // when F# Interactive is the host of the design time assembly,
              // all namespaces are prefixed with FSI_, in the runtime assembly
              // the name won't have that prefix
              fullName.Substring(fullName.IndexOf('.') + 1)
            else 
              fullName
          let getType fullName =
            if asm.FullName.StartsWith "FSI-ASSEMBLY" then
              // when F# Interactive is the host of the design time assembly,
              // for each type in the runtime assembly there might be multiple
              // versions (FSI_0001.FullTypeName, FSI_0002.FullTypeName, etc).
              // Get the last one.
              asm.GetTypes() 
              |> Seq.filter (fun t -> (fixName t.FullName) = fullName)
              |> Seq.sortBy (fun t -> t.FullName)
              |> Seq.last
            else
              asm.GetType fullName
          let newT =
            if t.IsGenericType && not t.IsGenericTypeDefinition then 
              let genericType = t.GetGenericTypeDefinition()
              let newT = getType (fixName genericType.FullName)
              if newT = null then 
                null
              else
                let typeArguments = 
                  t.GetGenericArguments()
                  |> Array.map (replaceType asmMappings caches)
                newT.MakeGenericType(typeArguments)
            else 
              getType (fixName t.FullName)
          if newT = null then
            None
          else
            typeCache.Add((asm, t), newT)
            Some newT
    match List.choose getType asmCandidates with
    | [ t ] -> t
    | _ -> failwithf "Type '%O' not found in %A" t (asmCandidates |> List.map (fun asm -> asm.Location))

  // there might be multiple assemblies involved in generic types
  and private getAssemblies (_, assembliesCache:Dictionary<_,_>) t =
    let rec innerGetAssemblies (t:Type) = seq {
      if not <| t :? ProvidedSymbolType then
        yield t.Assembly
      if t.IsGenericType && not t.IsGenericTypeDefinition then
        for t in t.GetGenericArguments() do
          yield! innerGetAssemblies t
    }
    match assembliesCache.TryGetValue t with
    | true, asms -> asms
    | false, _ ->
        let asms = t |> innerGetAssemblies |> Seq.distinct |> Seq.toArray
        assembliesCache.Add(t, asms)
        asms

  and private replaceType asmMappings caches (t : Type) =    
    if t.GetType() = typeof<ProvidedSymbolType> then t
    elif t.GetType() = typeof<ProvidedTypeDefinition> then t
    else replace asmMappings (t, getAssemblies caches t) (fun asmCandidates -> getType asmCandidates t asmMappings caches)

  let private replaceProperty asmMappings caches (p : PropertyInfo) =
    if p.GetType() = typeof<ProvidedProperty> then p
    else replace asmMappings (p, getAssemblies caches p.DeclaringType) (fun asmCandidates ->
      let t = getType asmCandidates p.DeclaringType asmMappings caches
      let isStatic = 
        p.CanRead && p.GetGetMethod().IsStatic || 
        p.CanWrite && p.GetSetMethod().IsStatic
      let bindingFlags = 
        BindingFlags.Public ||| BindingFlags.NonPublic ||| 
          (if isStatic then BindingFlags.Static else BindingFlags.Instance)
      let newP = t.GetProperty(p.Name, bindingFlags)
      if newP = null then
        failwithf "Property '%O' of type '%O' not found in %A" p t (asmCandidates |> List.map (fun asm -> asm.Location))
      newP)

  let private replaceField asmMappings caches (f : FieldInfo) =
    if f.GetType() = typeof<ProvidedField> then f
    else replace asmMappings (f, getAssemblies caches f.DeclaringType) (fun asmCandidates ->
      let t = getType asmCandidates f.DeclaringType asmMappings caches
      let bindingFlags = 
        (if f.IsPublic then BindingFlags.Public else BindingFlags.NonPublic) ||| 
        (if f.IsStatic then BindingFlags.Static else BindingFlags.Instance)
      let newF = t.GetField(f.Name, bindingFlags)
      if newF = null then
        failwithf "Field '%O' of type '%O' not found in %A" f t (asmCandidates |> List.map (fun asm -> asm.Location))
      newF)
  
  let private replaceMethod asmMappings caches (m : MethodInfo) =
    if m.GetType() = typeof<ProvidedMethod> then m
    elif m.Name <> "UnboxGeneric" && m.DeclaringType.FullName = "Microsoft.FSharp.Core.LanguagePrimitives+IntrinsicFunctions" then m // these methods don't really exist, so there's no need to replace them
    else 
      let assemblies = 
        Array.append [| m.DeclaringType |] <| m.GetGenericArguments()
        |> Array.collect (getAssemblies caches)
      replace asmMappings (m, assemblies) (fun asmCandidates ->
        let t = getType asmCandidates m.DeclaringType asmMappings caches
        let parameterTypes = 
          m.GetParameters() 
          |> Array.map (fun p -> replaceType asmMappings caches p.ParameterType) 
        let newM =
          if m.IsGenericMethod then 
            let genericMethod = t.GetMethod(m.Name)
            if genericMethod = null then 
              null
            else
              let typeArguments = 
                m.GetGenericArguments()
                |> Array.map (fun t -> replaceType asmMappings caches t) 
              genericMethod.MakeGenericMethod(typeArguments)
          else 
            t.GetMethod(m.Name, parameterTypes)
        if newM = null then
          failwithf "Method '%O' of type '%O' not found in %A" m t (asmCandidates |> List.map (fun asm -> asm.Location))
        else
          newM)

  let private replaceConstructor asmMappings caches (c : ConstructorInfo) =
    if c.GetType() = typeof<ProvidedConstructor> then c
    else replace asmMappings (c, getAssemblies caches c.DeclaringType) (fun asmCandidates ->
      let t = getType asmCandidates c.DeclaringType asmMappings caches
      let parameterTypes = 
        c.GetParameters() 
        |> Array.map (fun p -> replaceType asmMappings caches p.ParameterType) 
      let newC = t.GetConstructor(parameterTypes)
      if newC = null then
        failwithf "Constructor '%O' of type '%O' not found in %A" c t (asmCandidates |> List.map (fun asm -> asm.Location))
      else
        newC)

  let private replaceUnionCase asmMappings caches (uci : UnionCaseInfo) exprs =
    replaceLazy asmMappings (lazy (Expr.NewUnionCase (uci, exprs)), getAssemblies caches uci.DeclaringType) (fun asmCandidates ->
      let t = getType asmCandidates uci.DeclaringType asmMappings caches
      let constructorMethod = t.GetMethod(uci.Name)
      let constructorMethod =
        if constructorMethod = null then 
          // property FSharpOption<T>.get_None()
          t.GetProperty(uci.Name).GetGetMethod() 
        else constructorMethod
      if constructorMethod = null then
        failwithf "Method '%s' of type '%O' not found in %A" uci.Name t (asmCandidates |> List.map (fun asm -> asm.Location))
      Expr.Call (constructorMethod, exprs))

  let private replaceRecord asmMappings caches (t:Type) exprs =
    replaceLazy asmMappings (lazy (Expr.NewRecord (t, exprs)), getAssemblies caches t) (fun asmCandidates ->
      let t = getType asmCandidates t asmMappings caches
      let c = t.GetConstructors() |> Seq.exactlyOne
      if c = null then
        failwithf "Constructor of record type '%O' not found in %A" t (asmCandidates |> List.map (fun asm -> asm.Location))
      Expr.NewObject (c, exprs))

  let private replaceVar asmMappings caches (varTable: IDictionary<_,_>) reversePass (v: Var) =
    if v.Type.GetType() = typeof<ProvidedTypeDefinition> then v
    else replace asmMappings (v, getAssemblies caches v.Type) (fun asmCandidates ->
      let createNewVar() = 
        Var (v.Name, getType asmCandidates v.Type asmMappings caches, v.IsMutable)
      if reversePass then
        let newVar = createNewVar()
        // store the original var as we'll have to revert to it later
        varTable.Add(newVar, v)
        newVar
      else
        match varTable.TryGetValue v with
        | true, v -> v
        | false, _ -> 
            // It's a variable local to the quotation
            let newVar = createNewVar()
            // store it so we reuse it from now on
            varTable.Add(v, newVar)
            newVar)
  
  let rec private replaceExpr asmMappings caches varTable reversePass quotation =
    let rt = replaceType asmMappings caches
    let rp = replaceProperty asmMappings caches
    let rf = replaceField asmMappings caches
    let rm = replaceMethod asmMappings caches
    let rc = replaceConstructor asmMappings caches
    let ru = replaceUnionCase asmMappings caches
    let rr = replaceRecord asmMappings caches
    let rv = replaceVar asmMappings caches varTable reversePass
    let re = replaceExpr asmMappings caches varTable reversePass
    
    match quotation with
    | Call (obj, m, args) -> 
        match obj with
        | Some obj -> Expr.Call (re obj, rm m, List.map re args)
        | None -> Expr.Call (rm m, List.map re args)
    | PropertyGet (obj, p, indexArgs) -> 
        match obj with
        | Some obj -> Expr.PropertyGet (re obj, rp p, List.map re indexArgs)
        | None -> Expr.PropertyGet (rp p, List.map re indexArgs)
    | PropertySet (obj, p, indexArgs, value) -> 
        match obj with
        | Some obj -> Expr.PropertySet (re obj, rp p, re value, List.map re indexArgs)
        | None -> Expr.PropertySet (rp p, re value, List.map re indexArgs)
    | NewObject (c, exprs) ->
        Expr.NewObject (rc c, List.map re exprs)
    | Coerce (expr, t) ->
        Expr.Coerce (re expr, rt t)
    | NewUnionCase (uci, exprs) ->
        ru uci (List.map re exprs)
    | NewRecord (t, exprs) ->
        rr t (List.map re exprs)
    | NewArray (t, exprs) ->
        Expr.NewArray (rt t, List.map re exprs)
    | TupleGet (expr, i) ->
        Expr.TupleGet (re expr, i)
    | NewDelegate (t, vars, expr) ->
        Expr.NewDelegate (rt t, List.map rv vars, re expr)
    | FieldGet (obj, f) -> 
        match obj with
        | Some obj -> Expr.FieldGet (re obj, rf f)
        | None -> Expr.FieldGet (rf f)
    | FieldSet (obj, f, value) -> 
        match obj with
        | Some obj -> Expr.FieldSet (re obj, rf f, re value)
        | None -> Expr.FieldSet (rf f, re value)
    | Let (var, value, body) -> 
        Expr.Let(rv var, re value, re body)
    | ShapeVar v -> 
        Expr.Var (rv v)
    | ShapeLambda _ -> 
        failwith ("It's not possible to create a Lambda when cross targetting to a different FSharp.Core.\n" +
                  "Make sure you're not calling a function with signature A->(B->C) instead of A->B->C (using |> causes this).")
    | ShapeCombination (o, exprs) -> 
        RebuildShapeCombination (o, List.map re exprs)

  /// Creates an AssemblyReplacer with the provided list of designTimeAssembly*runtimeAssembly mappings
  /// Should always receive the current running assembly paired with the RuntimeAssembly from TypeProviderConfig,
  /// and in case we're targetting a different .Net framework profile, the FSharp.Core version referenced
  /// by the current assembly paired with the FSharp.Core version referenced by the runtime assembly
  let create asmMappings =
    let asmMappingsReversed = asmMappings |> List.map (fun (a, b) -> b, a)
    let varTable = Dictionary<_, _>()
    let typeCache = Dictionary<_, _>()
    let assembliesCache = Dictionary<_, _>()
    let caches = typeCache, assembliesCache
    { new AssemblyReplacer with
        member __.ToRuntime (t:Type) = t |> replaceType asmMappings caches
        member __.ToRuntime (e:Expr) = e |> replaceExpr asmMappings caches varTable false
        member __.ToDesignTime (e:Expr) = e |> replaceExpr asmMappingsReversed caches varTable true }
