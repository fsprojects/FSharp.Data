// --------------------------------------------------------------------------------------
// Utilities for transforming F# quotations to reference types from different assemblies
// --------------------------------------------------------------------------------------

namespace ProviderImplementation

open System
open System.Collections.Generic
open System.IO
open System.Reflection
open Microsoft.FSharp.Quotations
open Microsoft.FSharp.Quotations.ExprShape
open Microsoft.FSharp.Quotations.Patterns
open Microsoft.FSharp.Reflection
open ProviderImplementation.ProvidedTypes

/// When we split a type provider into a runtime assembly and a design time assembly, we can no longer 
/// use quotations directly, because they will reference the wrong types. AssemblyReplacer fixes that 
/// by transforming the expressions generated by the quotations to have the right types. On all 
/// expressions  that we provide to InvokeCode and GetterCode of ProvidedMethod, ProvidedConstructor,
/// and ProvidedProperty, instead of (fun args -> <@@ doSomethingWith(%%args) @@>), we should use 
/// (fun args -> let args = replacer.ToDesignTime args in replacer.ToRuntime <@@ doSomethingWith(%%args) @@>)
/// When creating the Provided* type, we have to always specify the runtime type, and when it invokes
/// the function provided to InvokeCode and GetterCode, we to first transform the argument expressions
/// to the design time types, so we can splice it in the quotation, and then after that we have to convert
/// it back to the runtime type. A further complication arises because Expr.Var's have reference equality, so
/// when can't just create new Expr.Var's with the same variable name and a different type. When transforming
/// them from runtime to design time we keep them in a dictionary, so that when we convert them back to runtime
/// we can return the exact same instance that was provided to us initially.
/// Another limitation (not only of this method, but in general with type providers) is that we can never use 
/// expressions that use F# functions as parameters or return values, we always have to use felegates instead.
type AssemblyReplacer =

  /// Gets the equivalent runtime type
  abstract member ToRuntime : designTimeType:Type -> Type

  /// Gets an equivalent expression with all the types replaced with runtime equivalents
  abstract member ToRuntime : designTimeTypeExpr:Expr -> Expr

  /// Gets an equivalent expression with all the types replaced with designTime equivalents
  abstract member ToDesignTime: runtimeExpr:Expr -> Expr

[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module AssemblyReplacer =

  // We use a list for asmMappings because the Assembly type is not an IComparable and can't be stored in a map
  // In the originalsAsms list the first assembly has to be the assembly of the outer type
  // We use a lazy type for the original to avoid doing unneeded work in the discriminated unions case
  let private replaceLazy asmMappings (lazyOriginal : 'a Lazy, originalAsms) f =
    let toAsm = 
      asmMappings
      |> Seq.tryPick (fun (fromAsm, toAsm) ->
        if originalAsms |> List.exists (fun originalAsm -> originalAsm = fromAsm) && fromAsm = originalAsms.Head then
          // if we found a replacement for the outer type assembly, return it
          Some toAsm
        else
          None)
    let toAsm =
      match toAsm with
      | Some toAsm -> Some toAsm
      | None ->
          asmMappings
          |> Seq.tryPick (fun (fromAsm, toAsm) -> 
            if originalAsms |> List.exists (fun originalAsm -> originalAsm = fromAsm) then
              // if we found a replacement for a inner type, just return the original
              // assembly of the outer type to signal that it needs to be visited, but it
              // doesn't make sense to replace it with toAsm
              Some originalAsms.Head
            else
              None)
    match toAsm with
    | Some toAsm -> f toAsm
    | None -> lazyOriginal.Value

  let private replace asmMappings (original, originalAsms) f =
    replaceLazy asmMappings (lazy original, originalAsms) f

  let rec private getType (asm:Assembly) (t:Type) asmMappings (typeCache:Dictionary<_,_>) =
    match typeCache.TryGetValue((asm, t)) with
    | true, t -> t
    | false, _ ->
        let fixName (fullName:string) =
          if fullName.StartsWith("FSI_") then 
            // when F# Interactive is the host of the design time assembly,
            // all namespaces are prefixed with FSI_, in the runtime assembly
            // the name won't have that prefix
            fullName.Substring(fullName.IndexOf('.') + 1)
          else 
            fullName
        let getType fullName =
          if asm.FullName.StartsWith "FSI-ASSEMBLY" then
            // when F# Interactive is the host of the design time assembly,
            // for each type in the runtime assembly there might be multiple
            // versions (FSI_0001.FullTypeName, FSI_0002.FullTypeName, etc).
            // Get the last one.
            asm.GetTypes() 
            |> Seq.filter (fun t -> (fixName t.FullName) = fullName)
            |> Seq.sortBy (fun t -> t.FullName)
            |> Seq.last
          else
            asm.GetType fullName
        let newT =
          if t.IsGenericType && not t.IsGenericTypeDefinition then 
            let genericType = t.GetGenericTypeDefinition()
            let newT = getType (fixName genericType.FullName)
            if newT = null then 
              null
            else
              let typeArguments = 
                t.GetGenericArguments()
                |> Array.map (replaceType asmMappings typeCache)
              newT.MakeGenericType(typeArguments)
          else 
            getType (fixName t.FullName)
        if newT = null then
          failwithf "Type '%O' not found in '%s'" t asm.Location
        typeCache.Add((asm, t), newT)
        newT

  // there might be multiple assemblies involved in generic types
  and private getAssemblies t =
    let rec innerGetAssemblies (t:Type) = seq {
      if not <| t :? ProvidedSymbolType then
        yield t.Assembly
      if t.IsGenericType && not t.IsGenericTypeDefinition then
        for t in t.GetGenericArguments() do
          yield! innerGetAssemblies t
    }
    t |> innerGetAssemblies |> Seq.distinct |> Seq.toList

  and private replaceType asmMappings typeCache (t : Type) =    
    if t.GetType() = typeof<ProvidedSymbolType> then t
    elif t.GetType() = typeof<ProvidedTypeDefinition> then t
    else replace asmMappings (t, getAssemblies t) (fun toAsm -> getType toAsm t asmMappings typeCache)

  let private replaceProperty asmMappings typeCache (p : PropertyInfo) =
    if p.GetType() = typeof<ProvidedProperty> then p
    else replace asmMappings (p, getAssemblies p.DeclaringType) (fun toAsm ->
      let t = getType toAsm p.DeclaringType asmMappings typeCache
      let isStatic = 
        p.CanRead && p.GetGetMethod().IsStatic || 
        p.CanWrite && p.GetSetMethod().IsStatic
      let bindingFlags = 
        BindingFlags.Public ||| BindingFlags.NonPublic ||| 
          (if isStatic then BindingFlags.Static else BindingFlags.Instance)
      let newP = t.GetProperty(p.Name, bindingFlags)
      if newP = null then
        failwithf "Property '%O' of type '%O' not found in '%s'" p t toAsm.Location
      newP)

  let private replaceField asmMappings typeCache (f : FieldInfo) =
    if f.GetType() = typeof<ProvidedField> then f
    else replace asmMappings (f, getAssemblies f.DeclaringType) (fun toAsm ->
      let t = getType toAsm f.DeclaringType asmMappings typeCache
      let bindingFlags = 
        (if f.IsPublic then BindingFlags.Public else BindingFlags.NonPublic) ||| 
        (if f.IsStatic then BindingFlags.Static else BindingFlags.Instance)
      let newF = t.GetField(f.Name, bindingFlags)
      if newF = null then
        failwithf "Field '%O' of type '%O' not found in '%s'" f t toAsm.Location
      newF)
  
  let private replaceMethod asmMappings typeCache (m : MethodInfo) =
    if m.GetType() = typeof<ProvidedMethod> then m
    elif m.Name <> "UnboxGeneric" && m.DeclaringType.FullName = "Microsoft.FSharp.Core.LanguagePrimitives+IntrinsicFunctions" then m // these methods don't really exist, so there's no need to replace them
    else 
      let assemblies = 
        Array.append [| m.DeclaringType |] <| m.GetGenericArguments()
        |> List.ofArray
        |> List.collect getAssemblies
      replace asmMappings (m, assemblies) (fun toAsm ->
        let t = getType toAsm m.DeclaringType asmMappings typeCache
        let parameterTypes = 
          m.GetParameters() 
          |> Array.map (fun p -> replaceType asmMappings typeCache p.ParameterType) 
        let newM =
          if m.IsGenericMethod then 
            let genericMethod = t.GetMethod(m.Name)
            if genericMethod = null then 
              null
            else
              let typeArguments = 
                m.GetGenericArguments()
                |> Array.map (fun t -> replaceType asmMappings typeCache t) 
              genericMethod.MakeGenericMethod(typeArguments)
          else 
            t.GetMethod(m.Name, parameterTypes)
        if newM = null then
          failwithf "Method '%O' of type '%O' not found in '%s'" m t toAsm.Location
        else
          newM)

  let private replaceConstructor asmMappings typeCache (c : ConstructorInfo) =
    if c.GetType() = typeof<ProvidedConstructor> then c
    else replace asmMappings (c, getAssemblies c.DeclaringType) (fun toAsm ->
      let t = getType toAsm c.DeclaringType asmMappings typeCache
      let parameterTypes = 
        c.GetParameters() 
        |> Array.map (fun p -> replaceType asmMappings typeCache p.ParameterType) 
      let newC = t.GetConstructor(parameterTypes)
      if newC = null then
        failwithf "Constructor '%O' of type '%O' not found in '%s'" c t toAsm.Location
      else
        newC)

  let private replaceUnionCase asmMappings typeCache (uci : UnionCaseInfo) exprs =
    replaceLazy asmMappings (lazy (Expr.NewUnionCase (uci, exprs)), getAssemblies uci.DeclaringType) (fun toAsm ->
      let t = getType toAsm uci.DeclaringType asmMappings typeCache
      let constructorMethod = t.GetMethod(uci.Name)
      let constructorMethod =
        if constructorMethod = null then 
          // property FSharpOption<T>.get_None()
          t.GetProperty(uci.Name).GetGetMethod() 
        else constructorMethod
      if constructorMethod = null then
        failwithf "Method '%s' of type '%O' not found in '%s'" uci.Name t toAsm.Location
      Expr.Call (constructorMethod, exprs))

  let private replaceRecord asmMappings typeCache (t:Type) exprs =
    replaceLazy asmMappings (lazy (Expr.NewRecord (t, exprs)), getAssemblies t) (fun toAsm ->
      let t = getType toAsm t asmMappings typeCache
      let c = t.GetConstructors() |> Seq.exactlyOne
      if c = null then
        failwithf "Constructor of record type '%O' not found in '%s'" t toAsm.Location
      Expr.NewObject (c, exprs))

  let private replaceVar asmMappings typeCache (varTable: IDictionary<_,_>) reversePass (v: Var) =
    if v.Type.GetType() = typeof<ProvidedTypeDefinition> then v
    else replace asmMappings (v, getAssemblies v.Type) (fun toAsm ->
      let createNewVar() = 
        Var (v.Name, getType toAsm v.Type asmMappings typeCache, v.IsMutable)
      if reversePass then
        let newVar = createNewVar()
        // store the original var as we'll have to revert to it later
        varTable.Add(newVar, v)
        newVar
      else
        match varTable.TryGetValue v with
        | true, v -> v
        | false, _ -> 
            // It's a variable local to the quotation
            let newVar = createNewVar()
            // store it so we reuse it from now on
            varTable.Add(v, newVar)
            newVar)
  
  let rec private replaceExpr asmMappings typeCache varTable reversePass quotation =
    let rt = replaceType asmMappings typeCache
    let rp = replaceProperty asmMappings typeCache
    let rf = replaceField asmMappings typeCache
    let rm = replaceMethod asmMappings typeCache
    let rc = replaceConstructor asmMappings typeCache
    let ru = replaceUnionCase asmMappings typeCache
    let rr = replaceRecord asmMappings typeCache
    let rv = replaceVar asmMappings typeCache varTable reversePass
    let re = replaceExpr asmMappings typeCache varTable reversePass
    
    match quotation with
    | Call (obj, m, args) -> 
        match obj with
        | Some obj -> Expr.Call (re obj, rm m, List.map re args)
        | None -> Expr.Call (rm m, List.map re args)
    | PropertyGet (obj, p, indexArgs) -> 
        match obj with
        | Some obj -> Expr.PropertyGet (re obj, rp p, List.map re indexArgs)
        | None -> Expr.PropertyGet (rp p, List.map re indexArgs)
    | PropertySet (obj, p, indexArgs, value) -> 
        match obj with
        | Some obj -> Expr.PropertySet (re obj, rp p, re value, List.map re indexArgs)
        | None -> Expr.PropertySet (rp p, re value, List.map re indexArgs)
    | NewObject (c, exprs) ->
        Expr.NewObject (rc c, List.map re exprs)
    | Coerce (expr, t) ->
        Expr.Coerce (re expr, rt t)
    | NewUnionCase (uci, exprs) ->
        ru uci (List.map re exprs)
    | NewRecord (t, exprs) ->
        rr t (List.map re exprs)
    | NewTuple (exprs) ->
        Expr.NewTuple (List.map re exprs)
    | TupleGet (expr, i) ->
        Expr.TupleGet (re expr, i)
    | NewDelegate (t, vars, expr) ->
        Expr.NewDelegate (rt t, List.map rv vars, re expr)
    | FieldGet (obj, f) -> 
        match obj with
        | Some obj -> Expr.FieldGet (re obj, rf f)
        | None -> Expr.FieldGet (rf f)
    | FieldSet (obj, f, value) -> 
        match obj with
        | Some obj -> Expr.FieldSet (re obj, rf f, re value)
        | None -> Expr.FieldSet (rf f, re value)
    | Let (var, value, body) -> 
        Expr.Let(rv var, re value, re body)
    | ShapeVar v -> 
        Expr.Var (rv v)
    | ShapeLambda (v, expr) -> 
        //Expr.Lambda (rv v, re expr)
        failwith ("It's not possible to create a Lambda when cross targetting to a different FSharp.Core.\n" +
                  "Make sure you're not calling a function with signature A->(B->C) instead of A->B->C (using |> causes this).")
    | ShapeCombination (o, exprs) -> 
        RebuildShapeCombination (o, List.map re exprs)

  /// Creates an AssemblyReplacer with the provided list of designTimeAssembly*runtimeAssembly mappings
  /// Should always receive the current running assembly paired with the RuntimeAssembly from TypeProviderConfig,
  /// and in case we're targetting a different .Net framework profile, the FSharp.Core version referenced
  /// by the current assembly paired with the FSharp.Core version referenced by the runtime assembly
  let create asmMappings =
    let asmMappingsReversed = asmMappings |> List.map (fun (a, b) -> b, a)
    let variablesTable = new Dictionary<_, _>()
    let typeCache = new Dictionary<_, _>()
    { new AssemblyReplacer with
        member __.ToRuntime (t:Type) = t |> replaceType asmMappings typeCache
        member __.ToRuntime (e:Expr) = e |> replaceExpr asmMappings typeCache variablesTable false
        member __.ToDesignTime (e:Expr) = e |> replaceExpr asmMappingsReversed typeCache variablesTable true }
